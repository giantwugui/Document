### 网络IO模型

#### 1.阻塞I/O模型

* 缺省情况下，所有文件操作都是阻塞的。系统调用直到数据包到达且被复制到应用进程的缓冲区中或者发生错误，在次期间都是阻塞的。

#### 2.非阻塞I/O模型

* recvfrom从应用程到内核是，如果缓冲区没有数据，就会直接返回一个EWOULDBLOCK错误。一般进行轮询检查这个状态。

#### 3.I/O复用模型

* linux提供select/poll，将一个或多个fd传递给select或poll系统调用，阻塞在select上。这样select/poll就可以侦测多个fd是否就绪。由于select/poll顺序扫描fs是否就绪，同时支持的fs有限。Linux提供了更高性能的epoll，使用时间驱动方式代替顺序扫描，因此性能更高。当有fd就绪时，回调函数rollback

#### 4.信号驱动I/O模型

* 首先开启套接口信号驱动I/O功能，并通过系统调用sigaction执行一个信号处理函数(此系统调用立即返回，进程继续工作，它是非阻塞的)。当数据准备就绪时，为该进程生成一个SIGIO信号，通过信号回调通知应用程序读取数据，并通知主循环函数处理数据。

#### 5.异步I/O

* 告知内核启动某个操作，并让该操作在整个操作完成后(包括数据从内核复制到用户缓冲区)通知调用线程。**与信号I/O区别，信号I/O由内核通知什么时候可以开始I/O，二异步I/O则由内核通知什么时候I/O完成。**



### I/O多路复用技术

* 支持一个进程打开的socket描述符fd不受限制(仅限于操作系统的最大文件句柄数)
* I/O效率不会随着FD的数目增加而线性下降
* 是用mmap加速内核与用户空间的消息传递，避免了不必要的内存赋值
* epoll的api更加简单