## 1.Netty逻辑架构

Netty采用三层网络架构进行设计和开发

* (1) Reactor通讯调度层 包括Reactor线程 NioEventLoop及其父类，NioSocketChannel/NioServerSocketChannel及其父类，Bytebuffer 以击其衍生处来的各种Buffer，Unsage以及其衍生处来的各种内部类。该层的主要职责就是监听网络的读写和连接操作，负责将网络层的数据读取到内存缓冲区中，然后触发各种网络事件，将这些事件出发扫Pipeline中，由Pipeline管理的职责链来进行后续操作
* (2) 职责链ChannelPipeline 负责事件在职责链中的有序传播，同时负责动态地编排职责。职责链可以选择监听和处理自己关系的事件，它可以拦截处理和向后/向前传播事件。通常开发编解码Handler用于消息的编解码，这样上层业务层只需要关系处理业务逻辑即可，不需要感知底层的协议层差异和线程模型差异，是下降了架构层面的分层隔离
* (3) 业务逻辑编排层
  * 纯粹的业务逻辑编排
  * 其他应用层协议插件，用于特定协议相关的会话和链路管理。例如CMPP协议

架构的不同层面，需要关系和处理的对象都不同。对于业务开发之，只需要关系职责链的拦截和业务Handler的编排，关注服务层的业务逻辑开发即可。各种应用协议以插件的形式提供，只有协议开发人员需要关注协议插件。**这种分层的架构设计理念实现了NIO框架各层之间的解耦，便于上层业务协议栈的开发和业务逻辑的定制**

## 2.关键架构质量属性

### 2.1高性能

* 软件因素
  * 架构不合理导致的性能问题
  * 编码实现不合理导致的性能问题，例如锁的不当使用

* 硬件因素
  * 服务器硬件配置太低
  * 带宽，磁盘的IOPS等限制导致的I/O操作性能差
  * 测试环境被公用导致被测试软件产品受影响

**Netty架构实现高性能**

* **(1) 采用异步非阻塞的I/O类库，基于Reactor模型实现**，解决了传统同步阻塞I/O模式下一个服务前无法平滑处理线性增长的客户端的问题
* **(2) TCP接受和发送缓冲区使用直接内存替代堆内存**，避免了内存复制，提升了I/O读取和写入的性能
* **(3) 支持通过内存池的方式循环励用ByteBuf**，避免了频繁创建和销毁ByteBuf带来的性能损耗
* **(4) 可配置的I/O线程数，TCP参数等**，为不同的用户场景提供定制化的调优参数，满足不同的性能场景
* **(5) 采用环形数组缓冲区实现无锁化并发编程，代替传统的线程安全容器或者锁**
* **(6) 合理使用线程安全容器、原子类等，提升系统并发处理能力**
* **(7) 关键资源的处理使用单线程串行化的方式，避免多线程并发访问带来的锁竞争和额外的CPU资源消耗问题**
* **(8) 通过引用计数器及时地申请释放不再被引用的对象，细粒度的内存管理降低了GC频率，减少频繁GC带来的时延增大和CPU损耗**



### 2.2可靠性

* **通讯对端强制关闭连接** 在客户端和服务端正常通讯过程中，如果发生了网络闪断、对方进程宕机或者其他非正常关闭链路事件，通讯双方需要关闭和释放Socket句柄，才不会发生句柄的泄露
* **定制I/O故障** 当底层网络发生故障的时候，应该由底层的NIO框架负责释放资源，处理异常等，上层的业务应用不需要关系底层的处理细节。

* **链路有效性检测** 链路可用性检测，当由业务消息时无须心跳检测，可以由业务消息进行链路可用性检测。空闲时通过心跳消息检测
  * 读空闲超时检测 当连续周期T没有消息可读，触发超时Handler，用户可以基于读空闲超时发送心跳消息，进行链路检测。
  * 写空闲超时检测 当连续周期T没有消息可写，触发超时Handler，用户可以基于读空闲超时发送心跳消息，进行链路检测。

* **内存保护机制**

  * 通过对象引用计数器对Netty的ByteBuf等内置对象进行细粒度的内存申请和释放，对非法的对象引用进行检测和保护
  * 通过内存池重用Bytebuf，节省内存
  * 可设置内存容量上限，包括ByteBuf、线程池线程数等。

  如果长度解码器没有单个消息最大报文长度限制，当解码错位或者读取到畸形码流时，长度值可能是个超大整数值，很容易导致内存溢出。如果有上限保护，直接抛出解码异常，这样就避免了大内存分配。

* **优雅停机** 当系统退出时，JVM通过注册的Shutdown Hook 拦截到退出信号量，然后执行退出操作，释放相关模块的资源占用，将缓冲区的消息处理完成或者清空，将待刷新的数据持久化到磁盘或者数据库中，等到资源回收和缓冲区消息处理完成之后，在退出。

* **Reactor线程的保护** Reactor线程是I/O操作的核心。一旦发生故障会导致挂载其上的多路复用器和多个链路无法正常使用，因此他的可靠性要求非常高 catch (Throwable a)

* **规避NIO bug** epoll bug

  * 根据该bug特征，首先侦测该bug是否发生
  * 将问题Selector上注册的Channel转移到新创建的Selector
  * 关闭老的问题Selector,使用新创建的Selector

* **流量整形** 系统都有多个部件组成，不同部件的处理性能不同，为了防止下游组件性能低下导致崩溃，需要系统提供流量整形功能。

  **流量整形是一种主动调整流量输出速率的措施**

  *Netty流量整形原理*

  ​		**对每次读取到的ByteBuf可写字节数进行计算，获取当前的报文流量，然后与流量整形阈值对比。如果已经达到或者超过阈值。则计算等待时间delay，将当前的ByteBuf放到定时任务Task中缓存，由定时任务线程池在延迟Delay之后继续处理该ByeBuf**

  流量整形与流控的最大区别在于流控会拒绝消息，流量整形不会拒绝和丢弃消息，无论接受量多大。总能以近似恒定的速度下发消息。

### 2.3可定制性

* **责任链模式**：Channel Pipeline 基于责任链模式开发，便于业务逻辑的拦截、定制和扩展
* **基于接口的开发**：关键类库都提供了接口或者抽象类，如果Netty自身的实现无法满足用户的需求，可以由用户自定义实现相关接口
* **提供大量工厂类**：通过重载这些工厂类可以实现按需创建出用户实现的对象
* **提供了大量的系统参数供用户按需设置**，增强系统的场景定制性

### 2.4可扩展性

​		基于Netty的基础NIO框架，可以方便地进行应用层协议定制，例如HTTP协议栈、Thrift协议栈、FTP协议栈。这些扩展不需要修改Netty的源码，直接基于Netty的二进制类库即可实现协议的扩展和定制。

​		目前村子大量基于Netty框架开发的协议，例如基于Netty的HTTP协议、Dubbo协议、RocketMQ内部私有协议

## 3.Netty高性能之道

* **(1) 异步非阻塞通讯**
* **(2) 高效的Reactor线程模型**
* **(3) 无锁化的串行设计**
* **(4) 高性能并发编程**
  * volatile的大量正确使用
  * CAS和源自类的广泛使用
  * 线程安全容器的使用
  * 通过读写锁提升并发性能
* **(5) 高性能的序列化框架**
  * 序列化后的码流大小（网络带宽的占用）
  * 序列化&反序列化的性能 （CPU资源占用）
  * 是否支持跨语言 （异构系统的对接和开发语言切换）
* **(6) 零拷贝**
* **(7) 内存池**
* **(8) 灵活的TCP参数配置能力**

## 4.Netty SSL安全特性

* SSL单向认证

  * SSL 客户端向服务端传送客户端SSL协议的版本号、支持的加密算法中共类、产生的随机数、以及其他可选信息
  * 服务端返回握手应答，向客户端传送确认SSL协议的版本号、加密算法的种类、随机数以及其他信息
  * 服务端向客户端发送自己的公钥
  * 客户端对服务段的证书进行认证，服务端的合法性校验包括：证书是否过期、发行服务器证书的CA是否可靠、发行证书的公钥能否正确揭开服务器证书的’‘发行者的数字签名’、服务器证书上的域名是否和服务器的实际域名相匹配等
  * 客户端随机产生一个用于后面通讯的“对称密钥”，然后服务端的公钥对其加密，将加密后的“预主密码”传给服务器端
  * 服务端将自己的私钥节开加密的“预主密码”，然后执行一系列步骤来产生主密码
  * 客户端向服务端发出消息，指明后面的数据通讯将使用主密码为对称密钥，同时通知服务器客户端的握手过程结束
  * 服务端向客户端发出消息，指明后面的数据通讯将使用主密码为对称密钥，同时通知客户端服务器的握手过程结束
  * SSL 的握手结束，SSL安全通道建立，客户端和服务端开始使用功能相同的对称密钥对数据加密，然后通过Socket进行传输

* SSL双向认证

  服务端也需要对客户端进行安全认证

### 4.1 Netty扩展安全特性

##### IP地址黑名单

定义BlacklistHandler 继承自ChannelHandlerAdapter。添加链路注册、链路激活、读取消息、发送消息时候对对端的IP地址进行校验。如果在黑名单中，则拒绝当前操作，关闭链路。

##### 接入认证

接入认证策略非常多，通常是较强的安全认证策略，例如基于用户域名+密码的认证，认证内容往往采用加密的方式例如Base64+AES

* 链路首次激活的时候，客户端发送认证消息给服务端
* 服务端接收到客户端消息之后，根据消息内容进行判断，如果是首次接入的认证，则进行认证，认证失败，打印日志关闭链路；认证成功，继续业务逻辑
* 客户端接收到服务端消息，对消息类型进行判断，对于认证应答消息，如果成功继续业务逻辑，认证失败，打印日志关闭链路