### 1. 基础概念

#### 1.1 响应式编程

* **灵敏的：**可以快速响应，系统应该尽可能快地做出响应
* **可恢复的：**系统在运行汇总可能出现问题，但是能够有很强大的容错机制和修复机制保持响应性
* **可伸缩的：**在任何负载下，响应式编程都可以更具自身压力变化，请求减少时，通过减少资源释放服务器的压力，负载大时能够通过扩展算法和软硬件的方式扩展服务能力，以经济实惠的方式实现可绳索性
* **消息驱动的：**响应式编程存在异步消息机制，事件之间的协作时通过消息进行连接的。基于这样的理念，响应式编程提出了各种模型来满足响应式编程的理念。著名的有Reactor和Rxjava

#### 1.2 Reactor 模型

![image-20200818153502314](https://gitee.com/wuugui/cloudimage/raw/master/java/springboot/image-20200818153502314.png)

如果大部分请求是比较耗时的操作，当请求数量上来后，M调线程就不能及时响应用户。大量的线程就只能在请求队列中等待或者被系统所抛弃。对于后续的请求而言，要么信赖的线程等到旧县城运行完后才能提供服务，要么就被体统所抛弃。为了克服这一问题，提出了Reactor（反应器）模式。

![image-20200818153736383](https://gitee.com/wuugui/cloudimage/raw/master/java/springboot/image-20200818153736383.png)

首先客户端会向服务器注册感兴趣的事件，这样客户端就订阅了对应的事件，只是订阅事件不会给服务器发送请求。当客户端发生已经注册的事件时，就会触发服务器 的响应。当触发服务器响应时，服务器存在一个Selector线程，这个线程只是负责轮询客户端发送过来的事件，并不处理亲贵，当他接收到有客户端事件，就会找到对应的请求处理器，然后启用零为一条线程进行处理器。

因为Selector线程只是进行轮询，并不处理复杂的业务功能，所以它可以在轮询之后对请求做实时响应。由于事件存在很多种，所以请求处理器也存在多个，因此还需要进行区分事件的类型，所以Selector存在一个路由的问题。当请求处理器处理业务时，结果最终也会转换为数据流发送到客户端。

#### 1.3 Spring WebFlux 概述