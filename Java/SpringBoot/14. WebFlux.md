### 1. 基础概念

WebFlux，Web响应式编程框架。

#### 1.1 响应式编程

* **灵敏的：**可以快速响应，系统应该尽可能快地做出响应
* **可恢复的：**系统在运行中可能出现问题，但是能够有很强大的容错机制和修复机制保持响应性
* **可伸缩的：**在任何负载下，响应式编程都可以更具自身压力变化，请求减少时，通过减少资源释放服务器的压力，负载大时能够通过扩展算法和软硬件的方式扩展服务能力，以经济实惠的方式实现可绳索性
* **消息驱动的：**响应式编程存在异步消息机制，事件之间的协作时通过消息进行连接的。基于这样的理念，响应式编程提出了各种模型来满足响应式编程的理念。著名的有Reactor和Rxjava

响应式编程： 一般不需要很高的数据一致性，但是对于并发数和响应速度十分在意

#### 1.2 Reactor 模型

![image-20200818153502314](https://gitee.com/wuugui/cloudimage/raw/master/java/springboot/image-20200818153502314.png)

如果大部分请求是比较耗时的操作，当请求数量上来后，M调线程就不能及时响应用户。大量的线程就只能在请求队列中等待或者被系统所抛弃。对于后续的请求而言，要么信赖的线程等到旧县城运行完后才能提供服务，要么就被体统所抛弃。为了克服这一问题，提出了Reactor（反应器）模式。

![image-20200818153736383](https://gitee.com/wuugui/cloudimage/raw/master/java/springboot/image-20200818153736383.png)

首先客户端会向服务器注册感兴趣的事件，这样客户端就订阅了对应的事件，只是订阅事件不会给服务器发送请求。当客户端发生已经注册的事件时，就会触发服务器 的响应。当触发服务器响应时，服务器存在一个Selector线程，这个线程只是负责轮询客户端发送过来的事件，并不处理亲贵，当他接收到有客户端事件，就会找到对应的请求处理器，然后启用零为一条线程进行处理器。

因为Selector线程只是进行轮询，并不处理复杂的业务功能，所以它可以在轮询之后对请求做实时响应。由于事件存在很多种，所以请求处理器也存在多个，因此还需要进行区分事件的类型，所以Selector存在一个路由的问题。当请求处理器处理业务时，结果最终也会转换为数据流发送到客户端。

#### 1.3 Spring WebFlux 概述

![image-20200818141327723](https://gitee.com/wuugui/cloudimage/raw/master/java/springboot/image-20200818141327723.png)

对于响应式编程而言分为Router Functions、Spring WebFlux和HTTP/Reactive Streams

* **Router Functions：**是一个路由分发层，会根据请求的事件巨鼎采用什么类的方法处理客户端发送过来的事件请求。Reactor模式中，他就是Selector的作用

* **Spring WebFlux：**是一种控制层，类似Spring MVC框架的层级。主要处理业务逻辑前进行的封装和控制数据流返回格式等
* **HTTP/Reactive Streams：**将结果转换为数据流的过程。

Spring WebFlux，存在两种开发方式，一种类似于Spring MVC的模式，另一种是函数功能性的编程。

Reactor提供Flux和Mono封装数据流：

* Flux：存放0-N哥数据流序列，响应式框架会一个接一个地将他们发送到客户端
* Mono：存放0-1个数据流序列

**背压：**只对Flux有意义，对于客户端，响应能力跟服务端有差距，如果在很短事件内将大量数据流传输给客户端，那么客户端就可能被压垮。一般适用响应式拉取，也就是将服务端的数据划分为多个序列，一次仅发送一个数据流序列给客户端，当客户端处理完这个序列后，再给服务端发送消息，然后拉取第二个序列进行处理，处理完后再给服务端发送消息，知道所有数据流被完全处理。

#### 1.4 WebHandler 接口和运行流程

与Spring MVC使用DispatcherServelt不同的是Spring WebFlux使用的是WebHandler。与DispatcherServelt相似。

![image-20200818142838974](https://gitee.com/wuugui/cloudimage/raw/master/java/springboot/image-20200818142838974.png)

##### 1.4.1 DispatcherHandler 的 handle 方法

```java
@Override
public Mono<Void> handle(ServerWebExchange exchange) {
   if (this.handlerMappings == null) {
      return createNotFoundError();
   }
   return Flux//Reactive 框架封装数据流的类 Flux
         .fromIterable(this.handlerMappings)//循环HadnlerMapping
         .concatMap(mapping -> mapping.getHandler(exchange))//找到何合适的处理器
         .next()
         .switchIfEmpty(createNotFoundError())//如果出现找不到处理器的情况
         .flatMap(handler -> invokeHandler(exchange, handler))//通过反射运行处理器
         .flatMap(result -> handleResult(exchange, result));//解析结果，将其转换为对应的数据流序列
}
```

与Spring MVC一样们都是从HandlerMapping找到对应处理器，因此Spring WebFlux也沿用了@Controller、@RequestMapping、@GetMapping和@PostMapping等注解，通过这些配置路径就能够通过Handler方法找到对应的处理器。找打处理器后会通过invokeHandler方法运行处理器，该方法也是找到合适的HandlerAdapter去运行处理器的。

![image-20200820102739661](https://gitee.com/wuugui/cloudimage/raw/master/java/springboot/image-20200820102739661.png)

##### 1.4.2 引入依赖

```xml
<dependency>
   <groupId>org.springframework.boot</groupId>
   <artifactId>spring-boot-starter-data-mongodb-reactive</artifactId>
</dependency>
<dependency>
   <groupId>org.springframework.boot</groupId>
   <artifactId>spring-boot-starter-webflux</artifactId>
</dependency>
```

之所以引入MongoDB的依赖，是因为Spring WebFlux只能支持SPring Data Reactive，它是一种非阻塞的数据响应方式，但是数据库的开发往往是阻塞的，所以Spring Data Reactive并不能对数据库的开发给与有效支持。但是Spring Data Reactive可以支持Redis、MongoDB等NoSQL的开发。MongoDB时使用最广泛的方式。不要加载spring-boot-starter-web 的依赖，否则Spring只会加载Spring MVC，而非Spring WebFlux。

### 2. 通过Spring MVC 方式开发WebFlux服务端

#### 2.1 发持久层

```java
@Data
public class User implements Serializable {
   private static final long serialVersionUID = 3923229573077975377L;
   @Id
   private Long id;
   private SexEnum sex;
   @Field("user_name")
   private String userName;
   private String note;
}
```

应为使用了MongoDB，所以采用JPA作为持久层。这样就需要集成相关的接口。Spring WebFlux为响应式提供了接口ReactiveMongoRepository，这样通过继承它就声明了一个JPA接口

```java
@Repository
//请注意这里需要继承ReactiveMongoRepository
public interface UserRepository extends ReactiveMongoRepository<User, Long> {
   /**
     * 对用户名和备注进行模糊查询
     * @param userName —— 用户名称
     * @param note —— 备注
     * @return 符合条件的用户
     */
    public Flux<User> findByUserNameLikeAndNoteLike(String userName, String note);
}
```

ReactiveMongoRepository是一个为MongoDB提供的接口，将来就可以通过配置将他扫描到IoC容器中。findByUserNameLikeAndNoteLike是按照JPA规则命名的方法

#### 2.2 服务层

```java
public interface UserService {

    Mono<User> getUser(Long id);

    Mono<User> insertUser(User user);

    Mono<User> updateUser(User user);

    Mono<Void> deleteUser(Long id);

    Flux<User> findUsers(String userName, String note);
}
```

```java
@Service
public class UserServiceImpl implements UserService {
    @Autowired
    private UserRepository userRepository;

    @Override
    public Mono<User> getUser(Long id) {
        return userRepository.findById(id);
    }
    
    @Override
    public Mono<User> insertUser( User user) {
        return userRepository.save(user);
    }

    @Override
    public Mono<User> updateUser(User user) {
        return userRepository.save(user);
    }

    @Override
    public Mono<Void> deleteUser(Long id) {
        Mono<Void> result = userRepository.deleteById(id);
        return result;
    }

    @Override
    public Flux<User> findUsers(String userName, String note) {
        return userRepository.findByUserNameLikeAndNoteLike(userName, note);
    }

}
```

#### 2.3 控制层

```java
// REST风格控制器,
@RestController 
public class UserController {

   @Autowired
   private UserService userService;

   // 获取用户
   @GetMapping("/user/{id}")
   public Mono<UserVo> getUser(@PathVariable Long id) {
      return userService.getUser(id)
            // 从User对象转换为UserVo对象
            .map(u -> translate(u));
   }

   // 新增用户
   @PostMapping("/user")
   public Mono<UserVo> insertUser(@RequestBody User user) {
      return userService.insertUser(user)
            // 从User对象转换为UserVo对象
            .map(u -> translate(u));
   }

   // 更新用户
   @PutMapping("/user")
   public Mono<UserVo> updateUser(@RequestBody User user) {
      DispatcherHandler
      return userService.updateUser(user)
            // 从User对象转换为UserVo对象
            .map(u -> translate(u));
   }

   // 删除用户
   @DeleteMapping("/user/{id}")
   public Mono<Void> deleteUser(@PathVariable Long id) {
      return userService.deleteUser(id);
   }

   // 查询用户
   @GetMapping("/user/{userName}/{note}")
   public Flux<UserVo> findUsers(@PathVariable String userName, @PathVariable String note) {
      return userService.findUsers(userName, note)
            // 从User对象转换为UserVo对象
            .map(u -> translate(u));
   }

   @PostMapping("/user2/{user}")
   public Mono<UserVo> insertUser2(@PathVariable("user") User user) {
      return userService.insertUser(user)
            // 进行PO和VO之间的转换
            .map(u -> translate(u));
   }

   // 加入局部验证器
   @InitBinder
   public void initBinder(DataBinder binder) {
      binder.setValidator(new UserValidator());
   }

   @PostMapping("/user3")
   public Mono<UserVo> insertUser3(@Valid @RequestBody User user) {
      return userService.insertUser(user)
            // 进行PO和VO之间的转换
            .map(u -> translate(u));
   }
   
   @PutMapping("/user/name")
   public Mono<UserVo> updateUserName(@RequestHeader("id") Long id,  
           @RequestHeader("userName") String userName) {
       Mono<User> userMono = userService.getUser(id);
       User user = userMono.block();
       if (user == null) { // 查找不到用户信息，抛出运行异常消息......
           throw new RuntimeException("找不到用户信息");
       }
       user.setUserName(userName);
       return this.updateUser(user);
   }

   /***
    * 完成PO到VO的转换
    * 
    * @param user
    *            ——PO 持久对象
    * @return UserVo ——VO 视图对象
    */
   private UserVo translate(User user) {
      UserVo userVo = new UserVo();
      userVo.setUserName(user.getUserName());
      userVo.setSexCode(user.getSex().getCode());
      userVo.setSexName(user.getSex().getName());
      userVo.setNote(user.getNote());
      userVo.setId(user.getId());
      return userVo;
   }

}
```

@RestController 代表采用REST风格的控制器，Spring会将返回的内容转捍卫JSON数据序列。这里方法返回的是Flux<User>或者Mono<User>，Mono是一个0-1的数据流序列，而Flux是0-N个数据流序列。

#### 2.4 配置服务

```properties
spring.data.mongodb.host=localhost
spring.data.mongodb.port=27017
spring.data.mongodb.database=spring

spring.webflux.static-path-pattern=/static/**
```

#### 2.5 启动文件

```java
@SpringBootApplication(scanBasePackages= "com.springboot.webflux")
// 由于引入JPA，默认的情况下，需要配置数据源，
// 通过@EnableAutoConfiguration排除原有自动配置的数据源
@EnableAutoConfiguration(exclude={DataSourceAutoConfiguration.class})
// 在WebFlux下，驱动MongoDB的JPA接口
@EnableReactiveMongoRepositories(basePackages= "com.springboot.webflux.repository")
public class WebFluxApplication {

    public static void main(String[] args) {
        SpringApplication.run(WebFluxApplication.class, args);
    }
    
}
```

因为引入了JPA，所以默认给情况下Spring Boot会尝试装配关系数据库数据源(Datasource)，使用的MOngoDB没有关系数据库，所以使用@EnableAutoConfiguration排除数据源的初始化。WebFlux中是哟共响应式的MonogoDB的JPA接口，需要使用注解EnableReactiveMongoRepositories进行驱动，

### 3. 客户端开发

现今的微服务理念中，会将大型的系统分为多个微服务系统。好处在于各个位系统相对独立，便于开发和维护，简化开发人员负担。

![image-20200820151430720](https://gitee.com/wuugui/cloudimage/raw/master/java/springboot/image-20200820151430720.png)

为了方便微服务之间的调用，SPring WebFlux提供了WebClient类。比RestTemplate更为强大，通过它可以请求后端的服务。