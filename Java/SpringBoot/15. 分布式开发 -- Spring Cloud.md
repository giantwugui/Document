Spring Cloud是一套组件，可以细分为多种组件，如服务发现、配置中心、消息总线、负载均衡、断路器和数据监控等。

* **服务治理和服务发现：**主要使用NetFlix Eureka作为服务质量伦理的。Spring Cloud对其进行了一次封装，可以以Spring Boot风格使用它，*通过服务注册将单个微服务节点注册给服务治理中心，这样服务治理中心就可以治理单个微服务节点。服务发现则是微服务节点可以对服务治理中心发送消息，使得服务治理中心可以将新的微服务节点纳入管理。*

* **客户端负载均衡：**微服务的开发中，将一个大系统拆分为多个微服务系统，各个微服务系统之间需要相互协作才能完成业务需求。每个微服务系统可能存在多个节点，当一个微服务调用另外一个微服务时，服务提供者需要负载均衡算法提供一个节点进行响应。**负载均衡是分布式必须实施的方案。**作用：分摊服务的压力，即使响应。此外，可能出现某个节点故障的风险，通过负载均衡算法就可以将腹胀节点排除，使后续请求发散到其他可用节点上，体现了Spring Cloud的高可用。Spring Cloud 提供了Ribbon来实现这些功能。
* **声明服务调用：**对于REST风格的调用，如果是哟共RestTemplate会比较繁琐，可读性不高。为了简化多次调用的夫再度，Spring Cloud提供了接口式的声明服务调用编程 Feign。**请求其他微服务时，就如同调度本地服务的java接口一样。**
* **断路器：**在分布式中，因为存在网络延迟或者故障，一些服务掉员工无法及时响应。如果此时服务消费者还在大量调用这些网络延迟或者故障的服务提供者，很快消费者也会应为大量的等待，造成积压。最终导致其自身出现服务瘫痪。为了克服这个问题，Spring Cloud提供了NetFlix的开源框架Hystrix来处理这些问题。当服务消费者长期得不到提供者响应时，就可以进行**降级、服务断路、线程和信号隔离、请求缓存或者、合并处理**。
* **API网关：**Spring Cloud中API网关式Zuul。网关作用：
  * **将请求的地址映射为真实服务器的地址**，例如，用户请求http://localhost/user/1而真实的服务是http://localhost:8001/user/1和http://localhost:8002/user/1都可以。这是就可以通过网关使得localhost/user映射为对应真实服务器的地址。**作用就是路由分发，从而降低单个节点的负载。可以称为服务端负载均衡。从高可用的角度来说，则一个请求地址可以映射到堕胎服务上，如果单点出现故障，其他节点也能提供服务，这样就是一个高可用的服务了。**
  * **过滤服务**，互联网中，服务器可能面临各种攻击，Zuul提供了过滤器，通过它过滤那些恶意或者无效的请求，把它们排除在服务网站之外，降低网站服务风险。

其他分布式服务技术：分布式事务、分布式数据一致性、消息总线等。

Spring Cloud 微服务实例:

![image-20200824173349525](https://gitee.com/wuugui/cloudimage/raw/master/java/springboot/image-20200824173349525.png)

### 1. 服务治理和服务发现 -- Eureka

#### 1.1 配置服务治理节点

Eureka是构建Spring Cloud分布式最为核心和基础的模块。作用是注册和发现哥哥Spring Boot微服务，并提供监控和管理的功能。

##### 1.1.1 引入依赖

```xml
<dependencies>
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>

    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-devtools</artifactId>
        <scope>runtime</scope>
        <optional>true</optional>
    </dependency>
    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
        <optional>true</optional>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-test</artifactId>
        <scope>test</scope>
        <exclusions>
            <exclusion>
                <groupId>org.junit.vintage</groupId>
                <artifactId>junit-vintage-engine</artifactId>
            </exclusion>
        </exclusions>
    </dependency>
</dependencies>

<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-dependencies</artifactId>
            <version>${spring-cloud.version}</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>
```

引入了Eureka模块的包。启用它需要在Spring Boot的启动文件上加入注解@EnableEurekaServer

```java
@SpringBootApplication
@EnableEurekaServer
public class DemoServerApplication {

    public static void main(String[] args) {
        SpringApplication.run(DemoServerApplication.class, args);
    }

}
```

##### 1.1.2 配置Eureka

```properties
spring.application.name=server
server.port=7001
eureka.instance.hostname=localhost
eureka.client.register-with-eureka=false
eureka.client.fetch-registry=false
eureka.client.serviceUrl.defaultZone=http://localhost:7001/eureka/
```

* **spring.application.name**：配置为server，这是一个标识，表示某个微服务的共同标识。如果有第二个微服务节点启动时，也是讲这个配置设置为server，那么Spring Cloud就会认为它也是server这个微服务的一个节点。
* **eureka.client.register-with-eureka**：配置为false，因为在莫仍的情况下，项目会自动地查找服务治理中心去注册。这里项目自生就是服务治理中心，所以取消注册服务中心。
* **eureka.client.fetch-registry**：配置为false，它是一个检索服务的功能，因为服务治理中心是维护服务实例的，所以不需要这个功能
* **eureka.client.serviceUrl.defaultZone**：代表服务中心的域，将来可以提供给别的微服务注册

配置完成运行代码，就启动了服务治理的服务。浏览器输入http//:localhost:7001/

![image-20200825095252244](https://gitee.com/wuugui/cloudimage/raw/master/java/springboot/image-20200825095252244.png)

#### 1.2 服务发现

##### 1.2.1 引入服务发现

```xml
<dependencies>
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
    </dependency>

    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-test</artifactId>
        <scope>test</scope>
        <exclusions>
            <exclusion>
                <groupId>org.junit.vintage</groupId>
                <artifactId>junit-vintage-engine</artifactId>
            </exclusion>
        </exclusions>
    </dependency>
</dependencies>

<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-dependencies</artifactId>
            <version>${spring-cloud.version}</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>
```

引入服务发现的包，然后修改Spring Boot的启动文件，在Spring Cloud旧版本中中启用发现服务的注解@EnableDiscoveryClien，但是在新版本中只需要依赖 spring-cloud-starter-netflix-eureka-client 就不需要该注解了。该注解的含义是当前项目注册给服务治理中心

##### 1.2.2 配置服务发现的服务治理中心

```properties
#服务器端口
server.port=9001
#Spring 服务名称
spring.application.name=product
#治理客户端服务域
eureka.client.serviceUrl.defaultZone=http://localhost:7001/eureka/
```

使用了9001端口就，而应用名称为product，这个微服务名称将会注册给服务治理中心。而这个应用就会作为这个名称为PRODUCT服务的一个节点。治理客户端服务域是通过属性eureka.client.serviceUrl.defaultZone进行配置的，**它也配置了服务治理中心同样的地址，这样他就能够古注册到之前所胚子的服务治理中心**。

![image-20200825101156638](https://gitee.com/wuugui/cloudimage/raw/master/java/springboot/image-20200825101156638.png)

如上图，产品微服务已经注册给服务治理中心。在分布式服务中需要两个或者以上的产品微服务节点，在Spring Cloud中只需要修改端口配置。然后再启动Spring Boot应用程序即可。

![image-20200825110704295](https://gitee.com/wuugui/cloudimage/raw/master/java/springboot/image-20200825110704295.png)

需要注意的是，配置文件中的spring.application.name属性都必须配置为product，这样服务治理才会认为他们呢都是产品微服务的节点。红色的字，标识服务治理中心的一助攻自我保护，会检测自己是否还在活跃状态，它会统计心跳失败的比例是狗在15min内低于85%。

##### 1.2.3 配置用户服务

```properties
server.port=8001
spring.application.name=user
#治理客户端服务域
eureka.client.serviceUrl.defaultZone=http://localhost:7001/eureka/
```

![image-20200825111212328](https://gitee.com/wuugui/cloudimage/raw/master/java/springboot/image-20200825111212328.png)

#### 1.3 配置多个服务治理中心节点

因为服务治理中心也可能单个节点出现故障，导致服务不可用。如果有两个节点，当一个不可用后，另外一个节点依旧可用，这样就能保证服务可以正常处理业务，这就天线了高可用的特性。从高并发负载的角度而言，多个节点也有助于服务的负载均衡。

##### 1.3.1 配置新的服务治理中心节点

```properties
spring.application.name=server
server.port=7002
eureka.instance.hostname=localhost
eureka.client.serviceUrl.defaultZone=http://localhost:7001/eureka/
```

之前的配置修改为

```properties
spring.application.name=server
server.port=7001
eureka.instance.hostname=localhost
eureka.client.serviceUrl.defaultZone=http://localhost:7002/eureka/
```

![image-20200825113127123](C:\Users\wanxin\AppData\Roaming\Typora\typora-user-images\image-20200825113127123.png)

7001 和 7002 两个服务治理中心是通过相互注册来保持香菇监控的，关键点是属性 spring.application.name保持一致，这样就可以形成多个服务治理中心。

##### 1.3.2 将应用注册到多个服务治理中心

![image-20200825114300626](https://gitee.com/wuugui/cloudimage/raw/master/java/springboot/image-20200825114300626.png)

此时已经完成了服务注册功能，但是让各个微服务相互交互未完成。Spring 提供 Ribbon 和 Feign两个组件支持。

### 2. 微服务之间的调用

#### 2.1 Ribbon客户端负载均衡

##### 2.1.1 添加user pojo

```java
@Data
public class User implements Serializable {
    private static final long serialVersionUID = -2535737897308758054L;
    private Long id;
    private String userName;
    private int level;
    private String note;
}
```

##### 2.1.2 添加UserController

```java
@RestController
public class UserController {

    private Logger logger = Logger.getLogger(this.getClass());

    @Autowired
    private DiscoveryClient discoveryClient;

    @GetMapping("/user/{id}")
    public User getUser(@PathVariable("id") long id) {
        ServiceInstance serviceInstance = discoveryClient.getInstances("USER").get(0);

        User user = new User();
        user.setId(id);
        user.setLevel((int) (id % 3 + 1));
        user.setUserName("user_name" + id);
        user.setNote("note_" + id);
        return user;
    }
}
```

##### 2.1.3 产品微服务加入Ribbnon依赖

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-ribbon</artifactId>
</dependency>
```

##### 2.1.4 负载均衡初始化RestTemplate

```java
@SpringBootApplication
//@EnableDiscoveryClient //不需要该注解，引入以来后会自动注册给服务治理中心
public class DemoProductApplication {

    /**
     * 始化RestTemplate
     * 多节点负载均衡
     */
    @LoadBalanced
    @Bean
    public RestTemplate initRestTemplate() {
        return new RestTemplate();
    }

    public static void main(String[] args) {
        SpringApplication.run(DemoProductApplication.class, args);
    }

}
```

@LoadBalanced作用是让RestTemplate实现负载均衡，当这个RestTemplate对象调用用户服务请求的时候，Ribbon会自动给用户微服务节点实现负载均衡，这样请求就会分摊到欸服务的各个节点上，从而降低单点压力。

##### 2.1.5 使用Ribbon测试用户服务调用

```java
@RestController
@RequestMapping("/product")
public class UserController {

    @Autowired
    private RestTemplate restTemplate;

    @GetMapping("/ribbon")
    public User testRibbon() {

        User user = null;
        for (int i = 0; i < 10; i++) {

            //这里直接使用了USER这个微服务ID，代表用户微服务系统，该ID通过属性商品spring.appplication.name来指定
            user = restTemplate.getForObject("http://USER/user/" + (i + 1), User.Class);
        }
        return user;
    }
}
```

RestTemplate对象，这是自动实现客户端负载均衡的对象。方法中使用了“USER”这个字符串代替了服务器机器端口，这是一个服务ID。在Enreka服务器中可以看到它的各个节点，他是用户微服务通过属性spring.application.name来指定的。

地址栏输入http://localhost:9002/product/ribbon

![image-20200825174231282](https://gitee.com/wuugui/cloudimage/raw/master/java/springboot/image-20200825174231282.png)

#### 2.2 Feign声明式调用