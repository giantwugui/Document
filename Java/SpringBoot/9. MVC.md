Spring MVC定位于一个松散的组合，展示给用户的视图、控制器返回的数据模型、定位视图的视图解析器、和处理适配器等内容都是独立的。

## 1. Spring MVC框架的设计

![image-20200731110758347](https://gitee.com/wuugui/cloudimage/raw/master/java/springboot/image-20200731110758347.png)

处理请求先到达控制器（ Controller ),控制器的作用是进行请求分发，这样它会根据请求的内容去访问模型层（ Model ）； 在现今互联网系统中，数据主要从数据库和 NoSQL 中来，而且对于数据库而言往往还存在事务的机制，为了适应这样的变化，设计者会把模型层再细分为两层，即服务层（ Service ）和数据访问层（ DAO 当控制器取到由模型层返回 数据后 ，就将数据渲染到视图 中，这样就能够展现给用户了。

## 2. Spring MVC流程

![image-20200731110942587](https://gitee.com/wuugui/cloudimage/raw/master/java/springboot/image-20200731110942587.png)

上图数字代表的是执行的流程，但是Spring MVC并非一定要经过全流程。例如：@ReponseBody，是没有经过属兔皆系恶气和视图渲染的。

吐过再Spring Boot机制下启用Spring MVC，会自动初始化一些组件，DispatcherServlet、HandlerAdapter的实现类RequestMappingHandlerAdapter的组件。

```java
@Controller
@RequestMapping("/user")
public class UserController {

    @Autowired
    private UserService userService = null;

    @RequestMapping("/details")
    public ModelAndView details(Long id) {
        User user = userService.getUser(id);
        ModelAndView mv = new ModelAndView();
        mv.setViewName("user/details");
        mv.addObject("user", user);
        return mv;
    }
}
```

@RequestMapping代表请求路径和控制器的映射关系，他会在Web服务器启动Spring MVC时候，就被扫描到HandleMapping的机制中存储，之后再用户发起请求被DispatcherServlet兰级后，通过URI和其他的条件，通过HandlerMapper机制就能找到对应的控制器进行响应。只是通过HandlerMapping返回的是一个HandlerExecutionChain对象。

```java
public class HandlerExecutionChain {
    private static final Log logger = LogFactory.getLog(HandlerExecutionChain.class);
    //处理器
    private final Object handler;
    //拦截器
    @Nullable
    private HandlerInterceptor[] interceptors;
    @Nullable
    private List<HandlerInterceptor> interceptorList;
    //拦截器当前下标
    private int interceptorIndex;
}
```

* HandlerExecutionChain包含处理器，这里的处理器是对控制器的包装。因为控制器包含参数，处理器就可以读入HTTP和上下文的相关参数，然后再传递给控制器方法。再控制器处理完成返回后，处理器又可以通过配置信息对控制器的返回结果进行处理。同时还可以通过拦截处理器进一步增强处理器的功能。

* 得到了处理器，还需要运行，但是请求有多种：HTTP请求、按BeanName的请求、WebSocket的请求，多以还需要一个适配器去运行HandlerExecutionChain对象包含的处理器。这就是HandlerAdapter接口的实现类，HttpRequestHandlerAdapter。
* 通过请求类型，DispatcherServlet就会找到它来执行Web请求的HandlerExecutionChain对象包含的内容，这样就能够执行我们的处理器了。

```properties
spring.mvc.view.prefix=/WEB-INF/jsp/
spring.mvc.view.suffix=.jsp
```

通过求改配置，就能在Spring Boot的机制下定制InternalResourceViewResolver这个视图解析器的初始化，也就是再返回试图名称之后，它会以前缀和后缀以及视图名组成全路径定位视图。

视图解析器定位到视图后，视图的作用是将数据模型渲染，这样就能够响应用户的请求，这一步就是视图将数据模型渲染处来，展示给用户查看。

**有时候我们需要的只是JSON数据集，应为目前前后台分离的趋势，使用JSON已经是主流的方式。@ResponseBody会把数据转换为JSON数据集。同时也可以使用MappingJackson2JsonView转换处JSON**

![image-20200801135117556](https://gitee.com/wuugui/cloudimage/raw/master/java/springboot/image-20200801135117556.png)

```java
@RequestMapping("/detailsForJson")
public ModelAndView detailsForJson(Long id) {
    User user = userService.getUser(id);
    ModelAndView mv = new ModelAndView();
    MappingJackson2JsonView view = new MappingJackson2JsonView();
    mv.setView(view);
    mv.addObject(user);
    return mv;
}
```

MappingJackson2JsonView是一个非逻辑视图，并不需要视图解析器进行定位，他的作用只是将数据模型渲染为JON数据集来响应请求。因此Spring MVC中并不是每个步骤都是必须的，而是更具特别的需要会有不同的流程。也可以使用@ResponseBody，它是一个再处理器内部转换的。

![image-20200801135910190](https://gitee.com/wuugui/cloudimage/raw/master/java/springboot/image-20200801135910190.png)

## 3. 定制Spring MVC的初始化

虽然web.xml不是一个必须的配置文件。为了支持对于Spring MVC的配置，Spring提供了接口WebMvcConfigurer。再Spring Boot中，自定义是通配置类WebMvcAutoConfiguration定义的，他有静态内部类WebMvcAutoConfigurationAdapter，通过它Spring Boot就自动配置了Spring MVC的初始化。

![image-20200801140408568](https://gitee.com/wuugui/cloudimage/raw/master/java/springboot/image-20200801140408568.png)

WebMvcAutoConfigurationAdapter类中灰度如Spring配置Spring MVC属性来初始化对应组件

![image-20200801140606389](https://gitee.com/wuugui/cloudimage/raw/master/java/springboot/image-20200801140606389.png)

一般二堰只需要配置少数选项就可以使得Spring MVC工作。

## 4. Spring MVC 实例

### 4.1 控制器

```java
@Controller
@RequestMapping("/user")
public class UserController {

   @Autowired
   private UserService userService = null;

   // 展示用户详情
   @RequestMapping("/details")
   public ModelAndView details(Long id) {
      // 访问模型层得到数据
      User user = userService.getUser(id);
      // 模型和视图
      ModelAndView mv = new ModelAndView();
      // 定义模型视图
      mv.setViewName("user/details");
      // 加入数据模型
      mv.addObject("user", user);
      // 返回模型和视图
      return mv;
   }

   @RequestMapping("/detailsForJson")
   public ModelAndView detailsForJson(Long id) {
      // 访问模型层得到数据
      User user = userService.getUser(id);
      // 模型和视图
      ModelAndView mv = new ModelAndView();
      // 生成JSON视图
      MappingJackson2JsonView jsonView = new MappingJackson2JsonView();
      mv.setView(jsonView);
      // 加入模型
      mv.addObject("user", user);
      return mv;
   }

   @RequestMapping("/table")
   public ModelAndView table() {
      // 访问模型层得到数据
      List<User> userList = userService.findUsers(null, null);
      // 模型和视图
      ModelAndView mv = new ModelAndView();
      // 定义模型视图
      mv.setViewName("user/table");
      // 加入数据模型
      mv.addObject("userList", userList);
      // 返回模型和视图
      return mv;
   }

   @RequestMapping("/list")
   @ResponseBody
   public List<User> list(@RequestParam(value = "userName", required = false) String userName,
         @RequestParam(value = "note", required = false) String note) {
      // 访问模型层得到数据
      List<User> userList = userService.findUsers(userName, note);
      return userList;
   }
}
```

开发控制器首先是指定请求分支，这个任务是交由注解 @RequestMapping去完成的，这个注解可以标注类或者方法，当一个类被标注的时候，所有关于它的请求，都需要再@RequestMapping定义的URL下。当方法被标注后，也可以定义部分URL。配置了扫描路径之后，Spring MVC扫描机制就可以将其扫描，并且装载为HandlerMapping。

list方法，首先标注为@ResponseBody，这样Spring MVC就知道把结果转换为JSON。获取参数使用了@RequestParam，通过指定参数名成使得HTTP请求的参数和发给发的参数绑定，这个注解的默认规则是参数不能为空。

## 4. 深入Spring MVC 开发

#### 4.1 处理器映射

如果 Web 工程使用 Spring MV 那么它在启动阶段就会将注解RequestMapping 所配置的内容保存到处理器映射（HandlerMapping) 然后等待请求的到来，通过拦截请求信息与 HandlerMapping 行匹配，找到对应的处理器（它包含控制器处逻辑），并将处理器及其拦截器保存到HandlerExecutionChain 对象中，返回给 DispatcherServlet ，这样DispatcherServlet可以运行它们了。

![image-20200801143405272](https://gitee.com/wuugui/cloudimage/raw/master/java/springboot/image-20200801143405272.png)

![image-20200801143417330](https://gitee.com/wuugui/cloudimage/raw/master/java/springboot/image-20200801143417330.png)

可以通过配置项value或者path来设置请求URL，从而让对应的请求应黑色到控制器或其方法上。同时value和path可以通过正则是来让方法匹配多个请求。如果不是有必要，尽量不要这么做。**建议一个路径对应一个方法**

为了简化method配置项的配置。可以使用注解@GetMapping，@PutMapping，@PatchMapping，@PutMapping和@DeleteMapping。

### 4.2 获取控制器参数

处理器时堆控制器的包装，再处理器运行的过程中会调度控制器的方法，只是他在进入控制器方法之前按会对HTTP的参数和上下文进行解析，将他们转换为控制器所需的参数。这一步是处理器首先需要做的事。Spring提供了大量的转换规则，通过这些规则就能非常简单获取大部分参数 。

##### 4.2.1 在无注解下获取参数

在没有注解的情况下，Spring MVC也可以获取参数，且参数允许为空，唯一的要iu是参数名称和HTTP请求的参数名称一致。

```java
@GetMapping("/no/annotation")
@ResponseBody
public Map<String, Object> noAnnotation(Integer intVal, Long longVal, String str) {
	Map<String, Object> paramsMap = new HashMap<>();
	paramsMap.put("intVal", intVal);
	paramsMap.put("longVal", longVal);
	paramsMap.put("str", str);
	return paramsMap;
}
```
##### 4.2.2 使用@RequestParam获取参数

在前后端分离的驱使下，前端的迷宫明规则可能与后端的规则不同，这是需要报前端的参数与后端的对应起来。Spring MVC提供了注解@RequestParam来确定前后端参数名称的映射关系

```java
/**
 * 通过注解@RequestParam获取参数
 * 
 * @param intVal
 *            -- 整数
 * @param longVal
 *            -- 长整形
 * @param str
 *            --字符串
 * @return 响应JSON数据集
 */
@GetMapping("/annotation")
@ResponseBody
public Map<String, Object> requestParam(@RequestParam("int_val") Integer intVal,
		@RequestParam("long_val") Long longVal, @RequestParam("str_val") String strVal) {
	Map<String, Object> paramsMap = new HashMap<>();
	paramsMap.put("intVal", intVal);
	paramsMap.put("longVal", longVal);
	paramsMap.put("strVal", strVal);
	return paramsMap;
}
```
默认情况下@RequestParam标注的参数是蹦年为空的，为了让他能够为空，可以配置其属性required为false。

##### 4.2.3 传递数组

```java
@GetMapping("/requestArray")
@ResponseBody
public Map<String, Object> requestArray(int[] intArr, Long[] longArr, String[] strArr) {
    Map<String, Object> paramsMap = new HashMap<>();
    paramsMap.put("intArr", intArr);
    paramsMap.put("longArr", longArr);
    paramsMap.put("strArr", strArr);
    return paramsMap;
}
```

需要传递数组参数是，每个参数的数组元素只需要通过逗号分割即可。

http://localhost:8080/my/requestArray?intArr=1,2,3&longArr=4,5,6&strArr=str1,str2

##### 4.2.4 传递JSON

```java
@PostMapping("/insert")
@ResponseBody
public User insert(@RequestBody User user) {
   userService.insertUser(user);
   return user;
}
```

insert方法的参数标注为@RequestBody，意味着他将接受前端提交的JSON请求体，而在JOSN请求体与User类之间的睡醒名称是保持一致的，这样SprignMVC就会通过这层映射关系将JSON请求体转换为User对象。

##### 4.2.5 通过URL传递参数

REST风格网站，参数往往通过URL进行传递。例如获取编号为1的用户，URL 为/user/1。Spring MVC 可以通过处理器应黑色和注解@PathVariable的组合获取URL参数。首先通过处理器映射可以定位参数的位置和名称，而@PathVariable则可以通过名称来获取参数

```java
// {...}代表占位符，还可以配置参数名称
@GetMapping("/{id}")
// 响应为JSON数据集
@ResponseBody
// @PathVariable通过名称获取参数
public User get(@PathVariable("id") Long id) {
   return userService.getUser(id);
}
```

##### 4.2.6 获取格式化参数

格式化数据：货币、日期 yyyy-MM-dd。Spring MVC也提供了良好的支持。对日期和数字类型的转换注解进行处理，分别是 @DateTimeFormat 和 @NumberFormat

```java
// 获取提交参数
@PostMapping("/format/commit")
@ResponseBody
public Map<String, Object> format(Date date,
                                  @NumberFormat(pattern = "#,###.##") Double number) {
    Map<String, Object> dataMap = new HashMap<>();
    dataMap.put("date", date);
    dataMap.put("number", number);
    return dataMap;
}
```

添加配置

```properties
spring.mvc.format.date=yyyy-MM-dd
```

### 5. 自定义参数转换规则

#### 5.1 处理器获取参数逻辑

当请求到来时，在处理器执行的过程中，它首先会从HTTP请求和上下文环境来得到参数。如果是简单的参数他会以简单的转换器进行转换，而这些简单的转换器是Spring MVC自身已经提供了的。如果是转换HTTP请求体，他就会调用HttpMessageConverter接口的方法对请求的信息进行转换，首先他会先判断能否对请求实体进行转换，如果可以就会将其转换为Java类型。