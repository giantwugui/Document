Spring MVC定位于一个松散的组合，展示给用户的视图、控制器返回的数据模型、定位视图的视图解析器、和处理适配器等内容都是独立的。

## 1. Spring MVC框架的设计

![image-20200731110758347](https://gitee.com/wuugui/cloudimage/raw/master/java/springboot/image-20200731110758347.png)

处理请求先到达控制器（ Controller ),控制器的作用是进行请求分发，这样它会根据请求的内容去访问模型层（ Model ）； 在现今互联网系统中，数据主要从数据库和 NoSQL 中来，而且对于数据库而言往往还存在事务的机制，为了适应这样的变化，设计者会把模型层再细分为两层，即服务层（ Service ）和数据访问层（ DAO 当控制器取到由模型层返回 数据后 ，就将数据渲染到视图 中，这样就能够展现给用户了。

## 2. Spring MVC流程

![image-20200731110942587](https://gitee.com/wuugui/cloudimage/raw/master/java/springboot/image-20200731110942587.png)

上图数字代表的是执行的流程，但是Spring MVC并非一定要经过全流程。例如：@ReponseBody，是没有经过属兔皆系恶气和视图渲染的。

吐过再Spring Boot机制下启用Spring MVC，会自动初始化一些组件，DispatcherServlet、HandlerAdapter的实现类RequestMappingHandlerAdapter的组件。

```java
@Controller
@RequestMapping("/user")
public class UserController {

    @Autowired
    private UserService userService = null;

    @RequestMapping("/details")
    public ModelAndView details(Long id) {
        User user = userService.getUser(id);
        ModelAndView mv = new ModelAndView();
        mv.setViewName("user/details");
        mv.addObject("user", user);
        return mv;
    }
}
```

@RequestMapping代表请求路径和控制器的映射关系，他会在Web服务器启动Spring MVC时候，就被扫描到HandleMapping的机制中存储，之后再用户发起请求被DispatcherServlet兰级后，通过URI和其他的条件，通过HandlerMapper机制就能找到对应的控制器进行响应。只是通过HandlerMapping返回的是一个HandlerExecutionChain对象。

```java
public class HandlerExecutionChain {
    private static final Log logger = LogFactory.getLog(HandlerExecutionChain.class);
    //处理器
    private final Object handler;
    //拦截器
    @Nullable
    private HandlerInterceptor[] interceptors;
    @Nullable
    private List<HandlerInterceptor> interceptorList;
    //拦截器当前下标
    private int interceptorIndex;
}
```

* HandlerExecutionChain包含处理器，这里的处理器是对控制器的包装。因为控制器包含参数，处理器就可以读入HTTP和上下文的相关参数，然后再传递给控制器方法。再控制器处理完成返回后，处理器又可以通过配置信息对控制器的返回结果进行处理。同时还可以通过拦截处理器进一步增强处理器的功能。

* 得到了处理器，还需要运行，但是请求有多种：HTTP请求、按BeanName的请求、WebSocket的请求，多以还需要一个适配器去运行HandlerExecutionChain对象包含的处理器。这就是HandlerAdapter接口的实现类，HttpRequestHandlerAdapter。
* 通过请求类型，DispatcherServlet就会找到它来执行Web请求的HandlerExecutionChain对象包含的内容，这样就能够执行我们的处理器了。

```properties
spring.mvc.view.prefix=/WEB-INF/jsp/
spring.mvc.view.suffix=.jsp
```

通过求改配置，就能在Spring Boot的机制下定制InternalResourceViewResolver这个视图解析器的初始化，也就是再返回试图名称之后，它会以前缀和后缀以及视图名组成全路径定位视图。

视图解析器定位到视图后，视图的作用是将数据模型渲染，这样就能够响应用户的请求，这一步就是视图将数据模型渲染处来，展示给用户查看。

**有时候我们需要的只是JSON数据集，应为目前前后台分离的趋势，使用JSON已经是主流的方式。@ResponseBody会把数据转换为JSON数据集。同时也可以使用MappingJackson2JsonView转换处JSON**

![image-20200801135117556](https://gitee.com/wuugui/cloudimage/raw/master/java/springboot/image-20200801135117556.png)

```java
@RequestMapping("/detailsForJson")
public ModelAndView detailsForJson(Long id) {
    User user = userService.getUser(id);
    ModelAndView mv = new ModelAndView();
    MappingJackson2JsonView view = new MappingJackson2JsonView();
    mv.setView(view);
    mv.addObject(user);
    return mv;
}
```

MappingJackson2JsonView是一个非逻辑视图，并不需要视图解析器进行定位，他的作用只是将数据模型渲染为JON数据集来响应请求。因此Spring MVC中并不是每个步骤都是必须的，而是更具特别的需要会有不同的流程。也可以使用@ResponseBody，它是一个再处理器内部转换的。

![image-20200801135910190](https://gitee.com/wuugui/cloudimage/raw/master/java/springboot/image-20200801135910190.png)

## 3. 定制Spring MVC的初始化

虽然web.xml不是一个必须的配置文件。为了支持对于Spring MVC的配置，Spring提供了接口WebMvcConfigurer。再Spring Boot中，自定义是通配置类WebMvcAutoConfiguration定义的，他有静态内部类WebMvcAutoConfigurationAdapter，通过它Spring Boot就自动配置了Spring MVC的初始化。

![image-20200801140408568](https://gitee.com/wuugui/cloudimage/raw/master/java/springboot/image-20200801140408568.png)

WebMvcAutoConfigurationAdapter类中灰度如Spring配置Spring MVC属性来初始化对应组件

![image-20200801140606389](https://gitee.com/wuugui/cloudimage/raw/master/java/springboot/image-20200801140606389.png)

一般二堰只需要配置少数选项就可以使得Spring MVC工作。

## 4. Spring MVC 实例

### 4.1 控制器

```java
@Controller
@RequestMapping("/user")
public class UserController {

   @Autowired
   private UserService userService = null;

   // 展示用户详情
   @RequestMapping("/details")
   public ModelAndView details(Long id) {
      // 访问模型层得到数据
      User user = userService.getUser(id);
      // 模型和视图
      ModelAndView mv = new ModelAndView();
      // 定义模型视图
      mv.setViewName("user/details");
      // 加入数据模型
      mv.addObject("user", user);
      // 返回模型和视图
      return mv;
   }

   @RequestMapping("/detailsForJson")
   public ModelAndView detailsForJson(Long id) {
      // 访问模型层得到数据
      User user = userService.getUser(id);
      // 模型和视图
      ModelAndView mv = new ModelAndView();
      // 生成JSON视图
      MappingJackson2JsonView jsonView = new MappingJackson2JsonView();
      mv.setView(jsonView);
      // 加入模型
      mv.addObject("user", user);
      return mv;
   }

   @RequestMapping("/table")
   public ModelAndView table() {
      // 访问模型层得到数据
      List<User> userList = userService.findUsers(null, null);
      // 模型和视图
      ModelAndView mv = new ModelAndView();
      // 定义模型视图
      mv.setViewName("user/table");
      // 加入数据模型
      mv.addObject("userList", userList);
      // 返回模型和视图
      return mv;
   }

   @RequestMapping("/list")
   @ResponseBody
   public List<User> list(@RequestParam(value = "userName", required = false) String userName,
         @RequestParam(value = "note", required = false) String note) {
      // 访问模型层得到数据
      List<User> userList = userService.findUsers(userName, note);
      return userList;
   }
}
```

开发控制器首先是指定请求分支，这个任务是交由注解 @RequestMapping去完成的，这个注解可以标注类或者方法，当一个类被标注的时候，所有关于它的请求，都需要再@RequestMapping定义的URL下。当方法被标注后，也可以定义部分URL。配置了扫描路径之后，Spring MVC扫描机制就可以将其扫描，并且装载为HandlerMapping。

list方法，首先标注为@ResponseBody，这样Spring MVC就知道把结果转换为JSON。获取参数使用了@RequestParam，通过指定参数名成使得HTTP请求的参数和发给发的参数绑定，这个注解的默认规则是参数不能为空。

## 4. 深入Spring MVC 开发

#### 4.1 处理器映射

如果 Web 工程使用 Spring MV 那么它在启动阶段就会将注解RequestMapping 所配置的内容保存到处理器映射（HandlerMapping) 然后等待请求的到来，通过拦截请求信息与 HandlerMapping 行匹配，找到对应的处理器（它包含控制器处逻辑），并将处理器及其拦截器保存到HandlerExecutionChain 对象中，返回给 DispatcherServlet ，这样DispatcherServlet可以运行它们了。

![image-20200801143405272](https://gitee.com/wuugui/cloudimage/raw/master/java/springboot/image-20200801143405272.png)

![image-20200801143417330](https://gitee.com/wuugui/cloudimage/raw/master/java/springboot/image-20200801143417330.png)

可以通过配置项value或者path来设置请求URL，从而让对应的请求应黑色到控制器或其方法上。同时value和path可以通过正则是来让方法匹配多个请求。如果不是有必要，尽量不要这么做。**建议一个路径对应一个方法**

为了简化method配置项的配置。可以使用注解@GetMapping，@PutMapping，@PatchMapping，@PutMapping和@DeleteMapping。

### 4.2 获取控制器参数

处理器时堆控制器的包装，再处理器运行的过程中会调度控制器的方法，只是他在进入控制器方法之前按会对HTTP的参数和上下文进行解析，将他们转换为控制器所需的参数。这一步是处理器首先需要做的事。Spring提供了大量的转换规则，通过这些规则就能非常简单获取大部分参数 。

##### 4.2.1 在无注解下获取参数

在没有注解的情况下，Spring MVC也可以获取参数，且参数允许为空，唯一的要iu是参数名称和HTTP请求的参数名称一致。

```java
@GetMapping("/no/annotation")
@ResponseBody
public Map<String, Object> noAnnotation(Integer intVal, Long longVal, String str) {
	Map<String, Object> paramsMap = new HashMap<>();
	paramsMap.put("intVal", intVal);
	paramsMap.put("longVal", longVal);
	paramsMap.put("str", str);
	return paramsMap;
}
```
##### 4.2.2 使用@RequestParam获取参数

在前后端分离的驱使下，前端的迷宫明规则可能与后端的规则不同，这是需要报前端的参数与后端的对应起来。Spring MVC提供了注解@RequestParam来确定前后端参数名称的映射关系

```java
/**
 * 通过注解@RequestParam获取参数
 * 
 * @param intVal
 *            -- 整数
 * @param longVal
 *            -- 长整形
 * @param str
 *            --字符串
 * @return 响应JSON数据集
 */
@GetMapping("/annotation")
@ResponseBody
public Map<String, Object> requestParam(@RequestParam("int_val") Integer intVal,
		@RequestParam("long_val") Long longVal, @RequestParam("str_val") String strVal) {
	Map<String, Object> paramsMap = new HashMap<>();
	paramsMap.put("intVal", intVal);
	paramsMap.put("longVal", longVal);
	paramsMap.put("strVal", strVal);
	return paramsMap;
}
```
默认情况下@RequestParam标注的参数是蹦年为空的，为了让他能够为空，可以配置其属性required为false。

##### 4.2.3 传递数组

```java
@GetMapping("/requestArray")
@ResponseBody
public Map<String, Object> requestArray(int[] intArr, Long[] longArr, String[] strArr) {
    Map<String, Object> paramsMap = new HashMap<>();
    paramsMap.put("intArr", intArr);
    paramsMap.put("longArr", longArr);
    paramsMap.put("strArr", strArr);
    return paramsMap;
}
```

需要传递数组参数是，每个参数的数组元素只需要通过逗号分割即可。

http://localhost:8080/my/requestArray?intArr=1,2,3&longArr=4,5,6&strArr=str1,str2

##### 4.2.4 传递JSON

```java
@PostMapping("/insert")
@ResponseBody
public User insert(@RequestBody User user) {
   userService.insertUser(user);
   return user;
}
```

insert方法的参数标注为@RequestBody，意味着他将接受前端提交的JSON请求体，而在JOSN请求体与User类之间的睡醒名称是保持一致的，这样SprignMVC就会通过这层映射关系将JSON请求体转换为User对象。

##### 4.2.5 通过URL传递参数

REST风格网站，参数往往通过URL进行传递。例如获取编号为1的用户，URL 为/user/1。Spring MVC 可以通过处理器应黑色和注解@PathVariable的组合获取URL参数。首先通过处理器映射可以定位参数的位置和名称，而@PathVariable则可以通过名称来获取参数

```java
// {...}代表占位符，还可以配置参数名称
@GetMapping("/{id}")
// 响应为JSON数据集
@ResponseBody
// @PathVariable通过名称获取参数
public User get(@PathVariable("id") Long id) {
   return userService.getUser(id);
}
```

##### 4.2.6 获取格式化参数

格式化数据：货币、日期 yyyy-MM-dd。Spring MVC也提供了良好的支持。对日期和数字类型的转换注解进行处理，分别是 @DateTimeFormat 和 @NumberFormat

```java
// 获取提交参数
@PostMapping("/format/commit")
@ResponseBody
public Map<String, Object> format(Date date,
                                  @NumberFormat(pattern = "#,###.##") Double number) {
    Map<String, Object> dataMap = new HashMap<>();
    dataMap.put("date", date);
    dataMap.put("number", number);
    return dataMap;
}
```

添加配置

```properties
spring.mvc.format.date=yyyy-MM-dd
```

### 5. 自定义参数转换规则

#### 5.1 处理器获取参数逻辑

当请求到来时，在处理器执行的过程中，它首先会从HTTP请求和上下文环境来得到参数。如果是简单的参数他会以简单的转换器进行转换，而这些简单的转换器是Spring MVC自身已经提供了的。如果是转换HTTP请求体，他就会调用HttpMessageConverter接口的方法对请求的信息进行转换，首先他会先判断能否对请求实体进行转换，如果可以就会将其转换为Java类型。

![image-20200803094116710](https://gitee.com/wuugui/cloudimage/raw/master/java/springboot/image-20200803094116710.png)

HttpMessageConverter接口只是将HTTP的请求体转换为对应的Java对象。

**在Spring中，是通过WebDataBinder机制来获取参数的，他的主要作用是解析HTTP请求的上下文，然后在控制器的调用之前转换参数并且提供验证的功能，为调用控制器方法做准备。处理器会从HTTP请求中读取数据，然后通过三种接口来进行各类参数转换，者三种接口是Converter、Formatter和GenericConverter。**

Spring MVC的机制中这三种接口的实现类都采用了注册机的机制，默认的情况下Spring MVC已经在注册机内注册了许多的转换器，这样就可以实现大部分的数据类型转换。例如整形、长整形、字符串等参数。**当需要自定义转换规则时，只需要在注册机上注册转换器即可。**

![image-20200803095027439](https://gitee.com/wuugui/cloudimage/raw/master/java/springboot/image-20200803095027439.png)

控制器的参数是处理器通过Converter、Formatter和GenericConverter这三个接口转换出来的。

* Converter：一个普通的转换器。从HTTP对应的字符串转换为Integer类型
* Formatter：格式化转换器，类似于日期字符串就是通过它按照约定的格式转换为日期
* GenericConverter：将HTTP参数转换为数组

**Spring MVC提供了服务机制ConversionService接口管理数据类型转换，通常使用这个接口的子类DefaultFormattingConversionService对象来管理这些转换类。**

![image-20200803095823786](https://gitee.com/wuugui/cloudimage/raw/master/java/springboot/image-20200803095823786.png)

**在Spring Boot中提供了特殊的机制来管理这些转换器。Spring Boot的自动配置类WebMvcConfiguration还定义了内部类WebMvcAutoConfiguration-Adapter。**

![image-20200803100030326](https://gitee.com/wuugui/cloudimage/raw/master/java/springboot/image-20200803100030326.png)

子需要自定义Converter、Formatter和GenericConverter的接口的Bean，Spring Boot就会通过这个方法将他们注册到ConversionSErvice对象中。

#### 5.2 一对一转换器（Converter）

```java
@Component
public class StringToUserConverter implements Converter<String, User> {
    @Override
    public User convert(String userStr) {
        User user = new User();
        String []strArr = userStr.split("-");
        Long id = Long.parseLong(strArr[0]);
        String userName = strArr[1];
        String note = strArr[2];
        user.setId(id);
        user.setUserName(userName);
        user.setNote(note);
        return user;
    }
}
```

Converter接口的类型有原类型（S）和目标类型（T），通过convert转换。

```java
@GetMapping("/converter")
@ResponseBody
public User getUserByConverter(User user) {
   return user;
}
```

请求url

http://localhost:8080/user/converter?user=1-userName-note

#### 5.3 GenericConverter集合和数组转换

假若要增加多个用户，传递一个用户列表(List<User>)给控制器，此时Spring MVC会使用StringToCollectionConverter转换，这个类实现了GenericConverter接口，并且是Spring MVC内部已经注册的数组转换器。**首先会把字符串用逗号分割为一个个的子字符穿，然后根据原来行为String、目标乐星为User，找到对用的Converter进行转换。**已经定义了StringToUserConverter，这样就可以将字符串转换为User类。

```java
@GetMapping("/list")
@ResponseBody
public List<User> list(List<User> userList) {
   return userList;
}
```

http://localhost:8080/user/list?userList=1-userName1-note1,2-userName2-note2,3-userName3-note3

### 6. 数据验证

参数转换出来后，往往需要验证参数的合法性，因此Spring MVC提供了验证参数的机制。

#### 6.1 JSR-303 验证

JSR-303 验证主要通过注解方式进行。

验证POJO

```java
@Data
public class ValidatorPojo {

   // 非空判断
   @NotNull(message = "id不能为空")
   private Long id;

   @Future(message = "需要一个将来日期") // 只能是将来的日期
   // @Past //只能去过去的日期
   @DateTimeFormat(pattern = "yyyy-MM-dd") // 日期格式化转换
   @NotNull // 不能为空
   private Date date;

   @NotNull // 不能为空
   @DecimalMin(value = "0.1") // 最小值0.1元
   @DecimalMax(value = "10000.00") // 最大值10000元
   private Double doubleValue = null;

   @Min(value = 1, message = "最小值为1") // 最小值为1
   @Max(value = 88, message = "最大值为88") // 最大值88
   @NotNull // 不能为空
   private Integer integer;

   @Range(min = 1, max = 888, message = "范围为1至888") // 限定范围
   private Long range;

   // 邮箱验证
   @Email(message = "邮箱格式错误")
   private String email;

   @Size(min = 20, max = 30, message = "字符串长度要求20到30之间。")
   private String size;
}
```

```java
    @GetMapping("/valid/page")
    public String validPage() {
        return "/validator/pojo";
    }

    /***
     * 解析验证参数错误
     * @param vp —— 需要验证的POJO，使用注解@Valid 表示验证
     * @param errors  错误信息，它由Spring MVC通过验证POJO后自动填充
     * @return 错误信息Map
     */
    @RequestMapping(value = "/valid/validate")
    @ResponseBody
    public Map<String, Object> validate(
            @Valid @RequestBody ValidatorPojo vp, Errors errors) {
        Map<String, Object> errMap = new HashMap<>();
        // 获取错误列表
        List<ObjectError> oes = errors.getAllErrors();
        for (ObjectError oe : oes) {
            String key = null;
            String msg = null;
            // 字段错误
            if (oe instanceof FieldError) {
                FieldError fe = (FieldError) oe;
                key = fe.getField();// 获取错误验证字段名
            } else {
                // 非字段错误
                key = oe.getObjectName();// 获取验证对象名称
            }
            // 错误信息
            msg = oe.getDefaultMessage();
            errMap.put(key, msg);
        }
        return errMap;
    }
}
```

@Valid标识启动验证机制，他会自动地将最后的验证结果放入Errors对象中，这样就可以从中得到验证后的信息

#### 6.2 参数验证机制

WebDataBinder中处理可以注册转变换器，可可以注册验证其

**在Spring控制器中，允许使用注解@InitBinder，允许在进入控制器方法前修改WebDataBinder机制**。验证及接口Validator

![image-20200803104151484](https://gitee.com/wuugui/cloudimage/raw/master/java/springboot/image-20200803104151484.png)

自定义验证器

```java
public class UserValidator implements Validator {
   
   // 该验证器只是支持User类验证
   @Override
   public boolean supports(Class<?> clazz) {
      return clazz.equals(User.class);
   }

   // 验证逻辑
   @Override
   public void validate(Object target, Errors errors) {
      // 对象为空
      if (target == null) {
         // 直接在参数处报错，这样就不能进入控制器的方法了
         errors.rejectValue("", null, "用户不能为空");
         return;
      }
      // 强制转换
      User user = (User) target;
      // 用户名非空串
      if (StringUtils.isEmpty(user.getUserName())) {
         // 增加错误，可以进入控制器方法
         errors.rejectValue("userName", null, "用户名不能为空");
      }
   }
}
```

启用验证器

```java
/**
 * 调用控制器前先执行这个方法
 * 
 * @param binder
 */
@InitBinder
public void initBinder(WebDataBinder binder) {
   // 绑定验证器
   binder.setValidator(new UserValidator());
   // 定义日期参数格式，参数不再需注解@DateTimeFormat，boolean参数表示是否允许为空
   binder.registerCustomEditor(Date.class, new CustomDateEditor(new SimpleDateFormat("yyyy-MM-dd"), false));
}

/**
 * 
 * @param user
 *            -- 用户对象用StringToUserConverter转换
 * @param Errors
 *            --验证器返回的错误
 * @param date
 *            -- 因为WebDataBinder已经绑定了格式，所以不再需要注解
 * @return 各类数据
 */
@GetMapping("/validator")
@ResponseBody
public Map<String, Object> validator(@Valid User user, Errors Errors, Date date) {
   Map<String, Object> map = new HashMap<>();
   map.put("user", user);
   map.put("date", date);
   // 判断是否存在错误
   if (Errors.hasErrors()) {
      // 获取全部错误
      List<ObjectError> oes = Errors.getAllErrors();
      for (ObjectError oe : oes) {
         // 判定是否字段错误
         if (oe instanceof FieldError) {
            // 字段错误
            FieldError fe = (FieldError) oe;
            map.put(fe.getField(), fe.getDefaultMessage());
         } else {
            // 对象错误
            map.put(oe.getObjectName(), oe.getDefaultMessage());
         }
      }
   }
   return map;
}
```

initBinder方法使用@InitBinder，因此会在控制器方法前被执行，绑定自定义的验证器UserValidator，而且设置了日期的格式，所以在控制器方法中不再需要使用@DataTimeFormat定义日期格式化。@Valid标注User参数，Spring MVC会去遍历随影的验证其，当遍历到UserValidator时候，会执行supports方法。

验证，http://localhost:8080/user/validator?user=1--note&date=2018-1-1

### 7. 数据模型

数据模型的作用是绑定数据，为视图渲染做准备

![image-20200803111230246](https://gitee.com/wuugui/cloudimage/raw/master/java/springboot/image-20200803111230246.png)

如果在控制器方法参数中使用ModelAndView、Model或者ModelMap作为参数类型，Spring MVC会自动创建数据模型对象。

```java
@RequestMapping("/data")
@Controller
public class DataModelController {
    // 注入用户服务类
    @Autowired
    private UserService userService = null;
    
    // 测试Model接口
    @GetMapping("/model")
    public String useModel(Long id, Model model) {
        User user = userService.getUser(id);
        model.addAttribute("user", user);
        // 这里返回字符串，在Spring MVC中，会自动创建ModelAndView且绑定名称
        return "data/user";
    }
    
    // 测试modelMap类
    @GetMapping("/modelMap")
    public ModelAndView useModelMap(Long id, ModelMap modelMap) {
        User user = userService.getUser(id);
        ModelAndView mv = new ModelAndView();
        // 设置视图名称
        mv.setViewName("data/user");
        // 设置数据模型，此处modelMap并没有和mv绑定，这步系统会自动处理
        modelMap.put("user", user);
        return mv;
    }
    
    // 测试ModelAndView
    @GetMapping("/mav")
    public ModelAndView useModelAndView(Long id, ModelAndView mv) {
        User user = userService.getUser(id);
        // 设置数据模型
        mv.addObject("user", user);
        // 设置视图名称
        mv.setViewName("data/user");
        return mv;
    }
}
```

### 8. 视图和视图解析器

视图时渲染数据模型展示给用户的组件，在Spring MVC中分为逻辑视图和非逻辑视图。

* 逻辑视图：需要视图解析器（ViewResolver）进一步定位
* 非逻辑视图：不需要定位视图的位置，只需要直接将数据模型渲染出来即可，MappingJackson2JsonView

#### 8.1 视图设计

视图除了JSON和JSP视图之外，还有Excel、PDF等。他们都会实现Spring MVC定义的视图接口View

![image-20200803133027752](https://gitee.com/wuugui/cloudimage/raw/master/java/springboot/image-20200803133027752.png)

* getContentType：获取HTTP相应类型，返回的类型时文本、JSON数据集或者文件

* render：将数据模型渲染到视图，参数说明

  * model：数据模型，从控制器（或者由处理器自动绑定）返回的数据模型，这样render方法就可以把它渲染处来。大部分视图类由Spring MVC提供。只需要定义如何将数据模型渲染到视图中展示给用户即可。

    ![image-20200803133515533](https://gitee.com/wuugui/cloudimage/raw/master/java/springboot/image-20200803133515533.png)

    * MappingJakson2JsonView：会将数据模型渲染为Json数据及展示给用户查看
    * JstlView：是一个逻辑驶入，可以在控制器返回一个字符串，使用视图解析器去定位对应的JSP文件，就能找到对应的JSp文件，将数据模型传递进入，JstlView就会将数据模型渲染，展示数据给用户。
    * PDF和Execel视图等：只需要接受数据模型，然后通过自定义的渲染。

#### 8.2 视图实例-导出PDF文件

```java
public interface PdfExportService {
    public void make(Map<String, Object> model, Document document, PdfWriter writer,
                     HttpServletRequest request, HttpServletResponse response);
}
```

```java
public class PdfView extends AbstractPdfView {
    // 导出服务接口
    private PdfExportService pdfExportService = null;

    // 创建对象的时候载入导出服务接口
    public PdfView(PdfExportService pdfExportService) {
        this.pdfExportService = pdfExportService;
    }

    // 调用接口实现
    @Override
    protected void buildPdfDocument(Map<String, Object> model, Document document, PdfWriter writer,
                                    HttpServletRequest request, HttpServletResponse response) throws Exception {
        // 调用导出服务接口类
        pdfExportService.make(model, document, writer, request, response);
    }
}
```

在创建自定义PDF视图时候，需要自定义一个导出服务接口PdfExportService。通过实现这个接口，每个控制器都可以自定义其导出的逻辑。

```java
@GetMapping("/export/pdf")
public ModelAndView exportPdf(String userName, String note) {
    // 查询用户信息列表
    List<User> userList = userService.findUsers(userName, note);
    // 定义PDF视图
    View view = new PdfView(exportService());
    ModelAndView mv = new ModelAndView();
    // 设置视图
    mv.setView(view);
    // 加入数据模型
    mv.addObject("userList", userList);
    return mv;
}

private PdfExportService exportService() {
   // 使用Lambda表达式定义自定义导出
   return (model, document, writer, request, response) -> {
      try {
         // A4纸张
         document.setPageSize(PageSize.A4);
         // 标题
         document.addTitle("用户信息");
         // 换行
         document.add(new Chunk("\n"));
         // 表格，3列
         PdfPTable table = new PdfPTable(3);
         // 单元格
         PdfPCell cell = null;
         // 字体，定义为蓝色加粗
         Font f8 = new Font();
         f8.setColor(Color.BLUE);
         f8.setStyle(Font.BOLD);
         // 标题
         cell = new PdfPCell(new Paragraph("id", f8));
         // 居中对齐
         cell.setHorizontalAlignment(1);
         // 将单元格加入表格
         table.addCell(cell);
         cell = new PdfPCell(new Paragraph("user_name", f8));
         // 居中对齐
         cell.setHorizontalAlignment(1);
         table.addCell(cell);
         cell = new PdfPCell(new Paragraph("note", f8));
         cell.setHorizontalAlignment(1);
         table.addCell(cell);
         // 获取数据模型中的用户列表
         List<User> userList = (List<User>) model.get("userList");
         for (User user : userList) {
            document.add(new Chunk("\n"));
            cell = new PdfPCell(new Paragraph(user.getId() + ""));
            table.addCell(cell);
            cell = new PdfPCell(new Paragraph(user.getUserName()));
            table.addCell(cell);
            String note = user.getNote() == null ? "" : user.getNote();
            cell = new PdfPCell(new Paragraph(note));
            table.addCell(cell);
         }
         // 在文档中加入表格
         document.add(table);
      } catch (DocumentException e) {
         e.printStackTrace();
      }
   };
}
```

### 9. 文件上传

#### 9.1 Spring MVC对文件上传的支持

DispatcherServlet会使用适配器模式，将HttpServletRequest接口对象转换为MultipartHttpServletRequest对象，MultipartHttpServletRequest接口扩展了HttpServletRequest接口的所有方法，而且定义了一些操作文件的方法，通过这些方法实现对文件上传的操作。

![image-20200803140546351](https://gitee.com/wuugui/cloudimage/raw/master/java/springboot/image-20200803140546351.png)

在使用Spring MVC上传文件时，还需要配置MultipartHttpServletRequest，是通过MultipartResolver接口实现的。

![image-20200803140947214](https://gitee.com/wuugui/cloudimage/raw/master/java/springboot/image-20200803140947214.png)

在Spring Boot中，如果没有自定义MultipartResolver对象，会根据配置自动创建MultipartResolver对象，史记为StandardServletMultipartResolver。这样就能够将对上传的文件进行配置。

文件上传配置

```java
#是否启用Spring MVC多分文件上传功能
spring.servlet.multipart.enabled=true
spring.servlet.multipart.location=d:/springboot
#单个文件大小
spring.servlet.multipart.max-file-size=1
#所有文件大小
spring.servlet.multipart.max-request-size=20
#是否延迟多部件文件请求的参数和文件解析
spring.servlet.multipart.resolve-lazily=false
```

文件上传JSP

```jsp
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" 
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>文件上传</title>
</head>
    <body>
        <form method="post" 
                action="./part" enctype="multipart/form-data">
            <input type="file" name="file" value="请选择上传的文件" /> 
            <input type="submit" value="提交" />
        </form>
    </body>
</html>
```

```java
@Controller
@RequestMapping("/file")
public class FileController {
    /**
     * 打开文件上传请求页面
     * @return 指向JSP的字符串
     */
    @GetMapping("/upload/page")
    public String uploadPage() {
        return "/file/upload";
    }
    
    // 使用HttpServletRequest作为参数
    @PostMapping("/upload/request")
    @ResponseBody
    public Map<String, Object> uploadRequest(HttpServletRequest request) {
        boolean flag = false;
        MultipartHttpServletRequest mreq = null;
        // 强制转换为MultipartHttpServletRequest接口对象
        if (request instanceof MultipartHttpServletRequest) {
            mreq = (MultipartHttpServletRequest) request;
        } else {
            return dealResultMap(false, "上传失败");
        }
        // 获取MultipartFile文件信息
        MultipartFile mf = mreq.getFile("file");
        // 获取源文件名称
        String fileName = mf.getOriginalFilename();
        File file = new File(fileName);
        try {
            // 保存文件
            mf.transferTo(file);
        } catch (Exception e) {
            e.printStackTrace();
            return dealResultMap(false, "上传失败");
        } 
        return dealResultMap(true, "上传成功");
    }
    
    // 使用Spring MVC的MultipartFile类作为参数
    @PostMapping("/upload/multipart")
    @ResponseBody
    public Map<String, Object> uploadMultipartFile(MultipartFile file) {
        String fileName = file.getOriginalFilename();
        File dest = new File(fileName);
        try {
            file.transferTo(dest);
        } catch (Exception e) {
            e.printStackTrace();
            return dealResultMap(false, "上传失败");
        } 
        return dealResultMap(true, "上传成功");
    }
    
    @PostMapping("/upload/part")
    @ResponseBody
    public Map<String, Object> uploadPart(Part file) {
        // 获取提交文件名称
        String fileName = file.getSubmittedFileName();
        try {
            // 写入文件
            file.write(fileName);
        } catch (Exception e) {
            e.printStackTrace();
            return dealResultMap(false, "上传失败");
        } 
        return dealResultMap(true, "上传成功");
    }
    
    // 处理上传文件结果
    private Map<String, Object> dealResultMap(boolean success, String msg) {
        Map<String, Object> result = new HashMap<String, Object>();
        result.put("success", success);
        result.put("msg", msg);
        return result;
    }
}
```

### 10. 拦截器

当请求到达DispatcherServlet时，会更具HandlerMapping的机制找到处理器，这样就会返回一个HandlerExecutionChain对象，这个对象包含处理器和拦截器。这里的拦截器会对处理器进行拦截，这样就可以通过拦截器增加强处理的功能。

#### 10.1 拦截器的设计

所有拦截器都需要实现HandlerInterceptor接口。拦截器的执行错愕灰姑娘

![image-20200803150440762](https://gitee.com/wuugui/cloudimage/raw/master/java/springboot/image-20200803150440762.png)

#### 10.2 开发拦截器

```java
public class Interceptor1 implements HandlerInterceptor {
    @Override
    public boolean preHandle(HttpServletRequest request,
                             HttpServletResponse response, Object handler) throws Exception {
        System.out.println("处理器前方法");
        // 返回true，不会拦执行续的处理
        return true;
    }

    @Override
    public void postHandle(HttpServletRequest request,
                           HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
        System.out.println("处理器后方法");
    }

    @Override
    public void afterCompletion(HttpServletRequest request,
                                HttpServletResponse response, Object handler, Exception ex) throws Exception {
        System.out.println("处理器完成方法");
    }
}
```

注册拦截器。在配置文件中共实现WebMvcConfigurator接口，

```java
@Configuration
public class InterceptorConfig implements WebMvcConfigurer {

     @Override
     public void addInterceptors(InterceptorRegistry registry) {
      // 注册拦截器到Spring MVC机制，然后它会返回一个拦截器注册
      InterceptorRegistration ir = registry.addInterceptor(new Interceptor1());
      // 指定拦截匹配模式，限制拦截器拦截请求
      ir.addPathPatterns("/interceptor/*");
      }
}
```

指定了拦截模式，所以他只会拦截与正则式“/interceptor/*”匹配的请求

```java
@Controller
@RequestMapping("/interceptor")
public class InterceptorController {
   @GetMapping("/start")
   public String start() {
      System.out.println("执行处理器逻辑");
      return "/welcome";
   }
}
```

#### 10.4 多个拦截器顺序

```java
@Override
public void addInterceptors(InterceptorRegistry registry) {
    // 注册拦截器到Spring MVC机制，然后它会返回一个拦截器注册
    InterceptorRegistration ir = registry.addInterceptor(new Interceptor1());
    // 指定拦截匹配模式，限制拦截器拦截请求
    ir.addPathPatterns("/interceptor/*");

    // 注册拦截器到Spring MVC机制中
    InterceptorRegistration ir1 = registry.addInterceptor(new MulitiInterceptor1());
    // 指定拦截匹配模式
    ir1.addPathPatterns("/interceptor/*");
    // 注册拦截器到Spring MVC机制中
    InterceptorRegistration ir2 = registry.addInterceptor(new MulitiInterceptor2());
    // 指定拦截匹配模式
    ir2.addPathPatterns("/interceptor/*");
    // 注册拦截器到Spring MVC机制中
    InterceptorRegistration ir3 = registry.addInterceptor(new MulitiInterceptor3());
    // 指定拦截匹配模式
    ir3.addPathPatterns("/interceptor/*");
}
```

**责任链模式，对于处理器前方法采用先注册限制性，而处理器后方法和完成方法则是后注册后执行的规则。处理器前方法会执行，但是一旦返回false，则后续的拦截器、处理器和所有哦拦截器的处理器后方法都不会执行。完成方法afterCompletion指挥执行返回true的拦截器方法，而且顺序时先注册后执行**

### 11. 国际化

对于时间个语言的需求在各个国家之间不相同。为了让不同的人在格子熟悉语言和文化的环境办理业务，就需要对系统进行国际化

#### 11.1 国际化消息源

Spring MVC提供了国际化消息源机制----MessageSource接口体系，用来装载国际化消息。主要使用ResourceBundleMessageSourceg国际化消息源。

配置项

```java
spring.messages.encoding=UTF-8
#设置国际化属性名称，如果多个可以使用逗号分割，默认为message
spring.messages.basename=international
#设置国际化消息缓存超时秒数，默认永远不过期，0标识每次都重新加载
spring.messages.cache-duration=3600
#如果没有找到特定区域设置的文件，则设置是否返回到系统区域设置
spring.messages.fallback-to-system-locale=true
```

![image-20200803155548194](https://gitee.com/wuugui/cloudimage/raw/master/java/springboot/image-20200803155548194.png)

这些配置项大部分情况下都不需要配置，只需要配置几项常用的即可快速启动国际化的消息的读入。例：如果需要设置中国简体中文和美国英文的国际化消息，可以把来给你个属性（properties）文件放在resources目录，只是这里要求三个文件，文件名分别为 messages.properoties，messages_zh_CN.properoties和messages_us_US.properoties。

* messages.properoties：默认国际化文件，如果没有这个文件，Spring MVC将不再启用国际化的消息机制
* messages_zh-CN.properoties：表示简体中文的国际化消息
* messages_us_US.properoties：美国的国际化消息

这里配置文件名称都是以message开头，在默认的情况下国际化的默认选项spring.message.basename的值也为messages，这样就可以不用配置，如果配置文件不是以message开头，那么就需要按照自己的需求对它进行配置。

#### 11.2 国际化解析器

对于国际化，还需要确定用户是使用那个国际区域。Spring MVC 提供了LocaleResolver接口来确定用户的额国际化区域。

* AcceptHeaderLocaleResolver：使用浏览器头请求的信息去实现国际化区域。不常用。
* FixedLocaleResolver：固定的国际化区域。只能选择一种，用处不大，基本不用
* CookieLocaleResolver：将国际化区域信息设置到浏览器Cookie中，这样使得系统可以从Cookie中读取国际化信息来确定用户的国际化区域。如果禁用Cookie。莫仍的国际化区域会从浏览器请求中读出，也可以通过服务端由开发者配置。

* SessionLocaleResolver：类似于CookieLocaleResolver，只是将国际化信息设置在Session中，这样就能读取Session中的信息去确定用户的国际化区域。

![image-20200803161108646](https://gitee.com/wuugui/cloudimage/raw/master/java/springboot/image-20200803161108646.png)

Spring MVC提供了两个简单的配置项，以方便开发者能够以最快的速度配置国际化解析器。

```java
# 指定国际区域，可以覆盖“Accept-Language” 头信息
#spring.mvc.locale=zh_CN
#国际化解析器，可以选择fixed或者accept-header
#fixed代表固定的国际化，accept-header代表读取浏览器的“Accept-Language”头信息
#spring.mvc.locale-resolver=accept_header
```

可以通过配置启用FixedLocaleResolver或AcceptHeaderLocaleResolver两种解析器。默认情况下Spring Boot会使用AcceptHeaderLocaleResolver去顶国际化区域。如果只是希望采用浏览器请求头确定国际化区域，或者指定固定的国际化区域，都无须任何开发。

如果需要更加灵活地直嘀咕国际化区域，这是需要是哟共CookieLocaleReolver或者SessionLocaleReolver

#### 11.3 国际化实例 SessionLocaleReolver

实际上使用最多的时SessionLocaleReolver

##### 11.3.1 配置国际化消息

```properties
spring.messages.encoding=UTF-8
spring.messages.basename=international
spring.messages.cache-duration=3600
```

![image-20200803162243570](https://gitee.com/wuugui/cloudimage/raw/master/java/springboot/image-20200803162243570.png)

##### 11.3.2 创建国际化解析器

主要是SessionLocaleReolver。在Spring MVC中提供了拦截器LocaleChangeInterceptor，可以在处理器前处理相关的逻辑，也就是拦截器的preHandler方法的作用。这个拦截器可以拦截一个请求参数，通过这个参数可以确定其国际化信息，并且把国际化信息保存到Session中。流程如下：

![image-20200803162715523](https://gitee.com/wuugui/cloudimage/raw/master/java/springboot/image-20200803162715523.png)

```java
@Configuration
public class InterceptorConfig implements WebMvcConfigurer {

    // 国际化拦截器
    private LocaleChangeInterceptor lci = null;

    // 国际化解析器，请注意这个Bean Name要为localeResolver
    @Bean(name = "localeResolver")
    public LocaleResolver initLocaleResolver() {
        SessionLocaleResolver slr = new SessionLocaleResolver();
        // 默认国际化区域
        slr.setDefaultLocale(Locale.SIMPLIFIED_CHINESE);
        return slr;
    }

    // 创建国际化拦截器
    @Bean
    public LocaleChangeInterceptor localeChangeInterceptor() {
        if (lci != null) {
            return lci;
        }
        lci = new LocaleChangeInterceptor();
        // 设置参数名
        lci.setParamName("language");
        return lci;
    }

    // 给处理器增加国际化拦截器
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        // 拦截器在执行处理器前方法(preHandle)将请求的国际区域根据参数修改为对应的区域
        registry.addInterceptor(localeChangeInterceptor());

        addTestInterceptor(registry);
    }
}
```

LocaleResolver 方法创建了一个国际化拦截器。注意两点

* 保证其BeanName 为"localeResolver"，这是Spring MVC中的约定，否则就不会感知这个解析器
* 设置默认的国际化区域为简体中文，也就是说，当参数为空或者为失效的时候，就会使用这个默认的国际化规则

LocaleChangeInterceptor方法则是创建国际化拦截器，设置了一个名称为language的参数，也就是蓝机器将读取HTTP请求为language的参数，用以设置国际化参数，这样就可以通过这个参数的变化来设置用户的国际化区域。

addInterceptors 方法则是将拦截器localeChangeInterceptor添加到Spring MVC拦截器的机制中，让他能够拦截处理器，这样就能够实现修改国际化区域的作用。

##### 11.3.3 国际化控制器

```java
@Controller
@RequestMapping("/i18n")
public class I18nController {
   // 注入国际化消息接口对象
   @Autowired
   private MessageSource messageSource;

   // 后台获取国际化信息和打开国际化视图
   @GetMapping("/page")
   public String page(HttpServletRequest request) {
      // 后台获取国际化区域
      Locale locale = LocaleContextHolder.getLocale();
      // 获取国际化消息
      String msg = messageSource.getMessage("msg", null, locale);
      System.out.println("msg = " + msg);
      // 返回视图
      return "i18n/internationalization";
   }
}
```

##### 11.3.4 视图国际化

```java
<%@ page language="java" contentType="text/html; charset=UTF-8"
   pageEncoding="UTF-8"%>
<%@taglib prefix="mvc" uri="http://www.springframework.org/tags/form"%>
<%@taglib prefix="spring" uri="http://www.springframework.org/tags"%>
<html>
<head>
<title>Spring MVC国际化</title>
</head>
<body>
   <!-- 通过HTTP请求参数变化国际化 -->
   <a href="./page?language=zh_CN">简体中文</a>
   <a href="./page?language=en_US">美国英文</a>
   <h2>
      <!-- 找到属性文件变量名为welcome的配置 -->
      <spring:message code="msg" />
   </h2>
   <!-- 当前国际化区域 -->
   Locale: ${pageContext.response.locale }
</body>
</html>
```

这里的连接是通过language参数去修改国际化的，它与拦截器锁定义的参数名称保持一致，所以他会被拦截，用来确定国际化区域没这样就能实现国际化

![image-20200803164458377](https://gitee.com/wuugui/cloudimage/raw/master/java/springboot/image-20200803164458377.png)

### 12. Spring MVC其他功能

#### 12.1 @ReponseBody转换为JSON

在进入控制器方法前当遇到标注的＠RsponseBody 后，处理器就会记录这个方法的响应类型为 JSON 数据集。当执行完控制器返回后，处理器会启用结果解析器（ResultResolver）去解析这个结果，它会去轮询注册给Spring MVC HttpMessageConverter 接口的实现类。因为 MappingJackson2HttpMessageConverter 这个实现类己经被 Spring MVC 注册 ，加上 Spring MVC 将控制器的结果 型标明为 JSON ，所以就匹配上了。于是通过它就在处理器内部把结果转换为了 JSON 。当然有时候会轮询不到匹配的HttpMessageConverter ，那么它就会交由 Spring MVC 续流程去处理。如果控制器返回结果被MappingJackson2HttpMessageConverter 行了转换，那么后续的模型和视图（ Mode!AndView ）就返回null ，这样视图解析器和视图渲染将不再被执行。![image-20200803165009909](https://gitee.com/wuugui/cloudimage/raw/master/java/springboot/image-20200803165009909.png)

#### 12.2 重定向

通过个中国你方法将各种网络请求重新定个方向转到其他位置。加入：插入一个User数据之后就是用showUser展示用户

```java
// 显示用户
@GetMapping("/show")
public String showUser(Long id, Model model) {
    User user = userService.getUser(id);
    model.addAttribute("user", user);
    return "data/user";
}

// 使用字符串指定跳转
@GetMapping("/redirect1")
public String redirect1(String userName, String note) {
    User user = new User();
    user.setNote(note);
    user.setUserName(userName);
    // 插入数据库后，回填user的id
    userService.insertUser(user);
    return "redirect:/user/show?id=" + user.getId();
}

// 使用模型和视图指定跳转
@GetMapping("/redirect2")
public ModelAndView redirect2(String userName, String note) {
    User user = new User();
    user.setNote(note);
    user.setUserName(userName);
    userService.insertUser(user);
    ModelAndView mv = new ModelAndView();
    mv.setViewName("redirect:/user/show?id=" + user.getId());
    return mv;
}
```

使用参数id传递给showUser方法，redirec1和redirec2方法已经包含了user对象的全部信息，而在showUser中还要查询一次，显然不合理。**Spring MVC提供了RedirectAttributes，扩展了ModelMap接口，有一个addFlashAttribute方法，这个方法可以保存需要传递给重定位的数据**

```java
// 显示用户
// 参数user直接从数据模型RedirectAttributes对象中取出
@RequestMapping("/showUser")
public String showUser(User user, Model model) {
    System.out.println(user.getId());
    return "data/user";
}

// 使用字符串指定跳转
@RequestMapping("/redirect1")
public String redirect1(String userName, String note, RedirectAttributes ra) {
    User user = new User();
    user.setNote(note);
    user.setUserName(userName);
    userService.insertUser(user);
    // 保存需要传递给重定向的对象
    ra.addFlashAttribute("user", user);
    return "redirect:/user/showUser";
}

// 使用模型和视图指定跳转
@RequestMapping("/redirect2")
public ModelAndView redirect2(String userName, String note, RedirectAttributes ra) {
    User user = new User();
    user.setNote(note);
    user.setUserName(userName);
    userService.insertUser(user);
    // 保存需要传递给重定向的对象
    ra.addFlashAttribute("user", user);
    ModelAndView mv = new ModelAndView();
    mv.setViewName("redirect:/user/showUser");
    return mv;
}
```

被addFlashAttribute方法保存的参数，在控制器执行完成后，会被保存道Session对象中。当执行重定向，在进入重定向前先把Session中的参数去除，用以填充重定向方法的参数和数据模型，之后删除Session中的数据，然后就可以调用重定向方法，并将对象传递个重定向的方法。

#### 12.3 操作会话对象

Web应用中操作会话（HttpSession）对象十分普遍。Spring MVC主要是通过两个注解来操作HttpSession：

* @SessionAttribute：应用于参数，将HttpSession中的属性读出，赋予控制器的参数
* @SessionAttributes：只用用于类的注解，会将线管数据模型的属性保存到Session中

##### 12.3.1 测试操作HttpSession

```jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" pageEncoding="utf-8" %>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
    <meta content="text/html; charset=UTF-8" http-equiv="Content-Type">
    <title>Session</title>
</head>
<body>
<% session.setAttribute("id", 1L);
    response.sendRedirect("./session/test");%>
</body>
</html>
```

##### 12.3.2 控制器

```java
@Controller
@RequestMapping("/session")
//指定数据模型名称或者属性类型，保存到Session中
@SessionAttributes(names = {"user"}, types = Long.class)
public class SessionController {
    @Autowired
    private UserService userService;

    @GetMapping("/test")
    //@SessionAttribute 从HttpSession中去除数据，填充控制器方法参数
    public String test(@SessionAttribute("id") Long id, Model model)
    {
        model.addAttribute("new_id", id);

        User user = userService.getUser(id);
        model.addAttribute("user", user);
        return  "session/test";
    }
}
```

@SessionAttributes制定了名称和类型，他们时或的关系，当Spring MVC中数据模型的属性满足名称或者类型时，他就将属性保存道Session中。test方法中，首先使用注解@SessionAttribute =读出HttpSession保存的id参数然后保存 一个名称为 id_new的 Long 型参数。按照＠SessionAttributes 配置 类型 它将在控制器 行后被保存 Session中， 接着根据 id 询出用户，然后用名称user保存用户信息按照＠SessionAttributes配置的名称，它也将在控制器执行后被保存到Session中。

```jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" pageEncoding="utf-8" %>
<%@ page import="com.wugui.study.pojo.User" %>
<%@ page import="javax.jws.soap.SOAPBinding" %>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
    <meta content="text/html; charset=UTF-8" http-equiv="Content-Type">
    <title>测试SessionAttributes</title>
</head>
<body>
<%
    User user = (User) session.getAttribute("user");
    Long id = (Long) session.getAttribute("new_id");
    out.print("<br> user_name = " + user.getUserName());
    out.println("<br> id_name = " + id);
%>
</body>
</html>
```

#### 10.4 给控制器增加通知

Spring AOP中，可以通过通过通知来增强Bean的功能。 Spring MVC可以给控制器增加通知，于是在控制器方法的前后和异常发生时去执行不同的处理。

* @ControllerAdvice：定义一个控制器的通知类，允许定义一些关于增强控制器的各类通知和限定增强哪些控制器功能等
* @InitBinder：定义控制器参数绑定规则，如转换规则、格式化等，他会在参数转换之前执行
* @ExeceptionHandler：定义控制器发生异常后的操作。一般来说，发生异常后，可以跳转到指定的友好页面
* @ModelAttribute：可以在控制器方法执行之前，对数据模型进行操作

##### 10.4.1 定义控制器通知

```java
@ControllerAdvice(
        // 指定拦截的包
        basePackages = {"com.wugui.study.controller.advice.test.*"},
        // 限定被标注为@Controller的类才被拦截        
        annotations = Controller.class)
public class MyControllerAdvice {

    // 绑定格式化、参数转换规则和增加验证器等
    @InitBinder
    public void initDataBinder(WebDataBinder binder) {
        // 自定义日期编辑器，限定格式为yyyy-MM-dd，且参数不允许为空
        CustomDateEditor dateEditor =
                new CustomDateEditor(new SimpleDateFormat("yyyy-MM-dd"), false);
        // 注册自定义日期编辑器
        binder.registerCustomEditor(Date.class, dateEditor);
    }

    // 在执行控制器之前先执行，可以初始化数据模型
    @ModelAttribute
    public void projectModel(Model model) {
        model.addAttribute("project_name", "chapter10");
    }

    // 异常处理，使得被拦截的控制器方法发生异常时，都能用相同的视图响应
    @ExceptionHandler(value = Exception.class)
    public String exception(Model model, Exception ex) {
        // 给数据模型增加异常消息
        model.addAttribute("exception_message", ex.getMessage());
        // 返回异常视图
        return "exception";
    }
}
```

![image-20200804094247350](https://gitee.com/wuugui/cloudimage/raw/master/java/springboot/image-20200804094247350.png)

##### 10.4.2 控制器

```java
@Controller
@RequestMapping("/advice")
public class AdviceController {

    @GetMapping("/test")
    // 因为日期格式被控制器通知限定，所以无法再给出
    public String test(Date date, ModelMap modelMap) {
        // 从数据模型中获取数据
        System.out.println(modelMap.get("project_name"));
        // 打印日期参数
        System.out.println(DateUtils.format(date, "yyyy-MM-dd"));
        // 抛出异常，这样流转到控制器异常通知
        throw new RuntimeException("异常了，跳转到控制器通知的异常信息里");
    }
}
```

##### 10.4.3 异常页面

```jsp
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" 
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>异常页面</title>
</head>
<body>
    <h3><td>${exception_message}</td></h3>
</body>
</html>
```

#### 10.5 获取请求头参数

在HTTP请求中共，有些网站会利用请求头的数据进行身份验证，所以有时在控制器中还需要拿到请求头数据。Spring MVC中可以通过注解@RequestHeader获取。

##### 10.5.1 带请求头的HTTP请求

```jsp
<%@ page pageEncoding="UTF-8" %>
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>获取请求头参数</title>
    <!-- 加载Query文件-->
    <script src="https://code.jquery.com/jquery-3.2.0.js">
    </script>
    <script type="text/javascript">
        $.post({
            url: "./user",
            // 设置请求头参数
            headers: {id: '1'},
            // 成功后的方法
            success: function (user) {
                if (user == null || user.id == null) {
                    alert("获取失败");
                    return;
                }
                // 弹出请求返回的用户信息
                alert("id=" + user.id + ", user_name=" + user.userName + ", note=" + user.note);
            }
        });
    </script>
</head>
<body>
</body>
```

##### 10.5.1 Controller 使用 @RequestHeader接收请求头

```java
@GetMapping("/header/page")
public String headerPage() {
    return "header";
}

@PostMapping("/header/user")
@ResponseBody
// 通过@RequestHeader接收请求头参数
public User headerUser(@RequestHeader("id") Long id) {
    User user = userService.getUser(id);
    return user;
}
```

