Spring MVC定位于一个松散的组合，展示给用户的视图、控制器返回的数据模型、定位视图的视图解析器、和处理适配器等内容都是独立的。

## 1. Spring MVC框架的设计

![image-20200731110758347](https://gitee.com/wuugui/cloudimage/raw/master/java/springboot/image-20200731110758347.png)

处理请求先到达控制器（ Controller ),控制器的作用是进行请求分发，这样它会根据请求的内容去访问模型层（ Model ）； 在现今互联网系统中，数据主要从数据库和 NoSQL 中来，而且对于数据库而言往往还存在事务的机制，为了适应这样的变化，设计者会把模型层再细分为两层，即服务层（ Service ）和数据访问层（ DAO 当控制器取到由模型层返回 数据后 ，就将数据渲染到视图 中，这样就能够展现给用户了。

## 2. Spring MVC流程

![image-20200731110942587](https://gitee.com/wuugui/cloudimage/raw/master/java/springboot/image-20200731110942587.png)

上图数字代表的是执行的流程，但是Spring MVC并非一定要经过全流程。例如：@ReponseBody，是没有经过属兔皆系恶气和视图渲染的。

吐过再Spring Boot机制下启用Spring MVC，会自动初始化一些组件，DispatcherServlet、HandlerAdapter的实现类RequestMappingHandlerAdapter的组件。

```java
@Controller
@RequestMapping("/user")
public class UserController {

    @Autowired
    private UserService userService = null;

    @RequestMapping("/details")
    public ModelAndView details(Long id) {
        User user = userService.getUser(id);
        ModelAndView mv = new ModelAndView();
        mv.setViewName("user/details");
        mv.addObject("user", user);
        return mv;
    }
}
```

@RequestMapping代表请求路径和控制器的映射关系，他会在Web服务器启动Spring MVC时候，就被扫描到HandleMapping的机制中存储，之后再用户发起请求被DispatcherServlet兰级后，通过URI和其他的条件，通过HandlerMapper机制就能找到对应的控制器进行响应。只是通过HandlerMapping返回的是一个HandlerExecutionChain对象。

```java
public class HandlerExecutionChain {
    private static final Log logger = LogFactory.getLog(HandlerExecutionChain.class);
    //处理器
    private final Object handler;
    //拦截器
    @Nullable
    private HandlerInterceptor[] interceptors;
    @Nullable
    private List<HandlerInterceptor> interceptorList;
    //拦截器当前下标
    private int interceptorIndex;
}
```

HandlerExecutionChain包含处理器，这里的处理器是对控制器的包装。因为控制器包含参数，处理器就可以读入HTTP和上下文的相关参数，然后再传递给控制器方法。再控制器处理完成返回后，处理器又可以通过配置信息对控制器的返回结果进行处理。同时还可以通过拦截处理器进一步增强处理器的功能。