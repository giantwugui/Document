Spring MVC定位于一个松散的组合，展示给用户的视图、控制器返回的数据模型、定位视图的视图解析器、和处理适配器等内容都是独立的。

## 1. Spring MVC框架的设计

![image-20200731110758347](https://gitee.com/wuugui/cloudimage/raw/master/java/springboot/image-20200731110758347.png)

处理请求先到达控制器（ Controller ),控制器的作用是进行请求分发，这样它会根据请求的内容去访问模型层（ Model ）； 在现今互联网系统中，数据主要从数据库和 NoSQL 中来，而且对于数据库而言往往还存在事务的机制，为了适应这样的变化，设计者会把模型层再细分为两层，即服务层（ Service ）和数据访问层（ DAO 当控制器取到由模型层返回 数据后 ，就将数据渲染到视图 中，这样就能够展现给用户了。

## 2. Spring MVC流程

![image-20200731110942587](https://gitee.com/wuugui/cloudimage/raw/master/java/springboot/image-20200731110942587.png)

上图数字代表的是执行的流程，但是Spring MVC并非一定要经过全流程。例如：@ReponseBody，是没有经过属兔皆系恶气和视图渲染的。

吐过再Spring Boot机制下启用Spring MVC，会自动初始化一些组件，DispatcherServlet、HandlerAdapter的实现类RequestMappingHandlerAdapter的组件。

```java
@Controller
@RequestMapping("/user")
public class UserController {

    @Autowired
    private UserService userService = null;

    @RequestMapping("/details")
    public ModelAndView details(Long id) {
        User user = userService.getUser(id);
        ModelAndView mv = new ModelAndView();
        mv.setViewName("user/details");
        mv.addObject("user", user);
        return mv;
    }
}
```

@RequestMapping代表请求路径和控制器的映射关系，他会在Web服务器启动Spring MVC时候，就被扫描到HandleMapping的机制中存储，之后再用户发起请求被DispatcherServlet兰级后，通过URI和其他的条件，通过HandlerMapper机制就能找到对应的控制器进行响应。只是通过HandlerMapping返回的是一个HandlerExecutionChain对象。

```java
public class HandlerExecutionChain {
    private static final Log logger = LogFactory.getLog(HandlerExecutionChain.class);
    //处理器
    private final Object handler;
    //拦截器
    @Nullable
    private HandlerInterceptor[] interceptors;
    @Nullable
    private List<HandlerInterceptor> interceptorList;
    //拦截器当前下标
    private int interceptorIndex;
}
```

* HandlerExecutionChain包含处理器，这里的处理器是对控制器的包装。因为控制器包含参数，处理器就可以读入HTTP和上下文的相关参数，然后再传递给控制器方法。再控制器处理完成返回后，处理器又可以通过配置信息对控制器的返回结果进行处理。同时还可以通过拦截处理器进一步增强处理器的功能。

* 得到了处理器，还需要运行，但是请求有多种：HTTP请求、按BeanName的请求、WebSocket的请求，多以还需要一个适配器去运行HandlerExecutionChain对象包含的处理器。这就是HandlerAdapter接口的实现类，HttpRequestHandlerAdapter。
* 通过请求类型，DispatcherServlet就会找到它来执行Web请求的HandlerExecutionChain对象包含的内容，这样就能够执行我们的处理器了。

```properties
spring.mvc.view.prefix=/WEB-INF/jsp/
spring.mvc.view.suffix=.jsp
```

通过求改配置，就能在Spring Boot的机制下定制InternalResourceViewResolver这个视图解析器的初始化，也就是再返回试图名称之后，它会以前缀和后缀以及视图名组成全路径定位视图。

视图解析器定位到视图后，视图的作用是将数据模型渲染，这样就能够响应用户的请求，这一步就是视图将数据模型渲染处来，展示给用户查看。

**有时候我们需要的只是JSON数据集，应为目前前后台分离的趋势，使用JSON已经是主流的方式。@ResponseBody会把数据转换为JSON数据集。同时也可以使用MappingJackson2JsonView转换处JSON**

![image-20200801135117556](https://gitee.com/wuugui/cloudimage/raw/master/java/springboot/image-20200801135117556.png)

```java
@RequestMapping("/detailsForJson")
public ModelAndView detailsForJson(Long id) {
    User user = userService.getUser(id);
    ModelAndView mv = new ModelAndView();
    MappingJackson2JsonView view = new MappingJackson2JsonView();
    mv.setView(view);
    mv.addObject(user);
    return mv;
}
```

MappingJackson2JsonView是一个非逻辑视图，并不需要视图解析器进行定位，他的作用只是将数据模型渲染为JON数据集来响应请求。因此Spring MVC中并不是每个步骤都是必须的，而是更具特别的需要会有不同的流程。也可以使用@ResponseBody，它是一个再处理器内部转换的。

![image-20200801135910190](https://gitee.com/wuugui/cloudimage/raw/master/java/springboot/image-20200801135910190.png)

## 3. 定制Spring MVC的初始化

虽然web.xml不是一个必须的配置文件。为了支持对于Spring MVC的配置，Spring提供了接口WebMvcConfigurer。再Spring Boot中，自定义是通配置类WebMvcAutoConfiguration定义的，他有静态内部类WebMvcAutoConfigurationAdapter，通过它Spring Boot就自动配置了Spring MVC的初始化。

![image-20200801140408568](https://gitee.com/wuugui/cloudimage/raw/master/java/springboot/image-20200801140408568.png)

WebMvcAutoConfigurationAdapter类中灰度如Spring配置Spring MVC属性来初始化对应组件

![image-20200801140606389](https://gitee.com/wuugui/cloudimage/raw/master/java/springboot/image-20200801140606389.png)

一般二堰只需要配置少数选项就可以使得Spring MVC工作。

## 4. Spring MVC 实例

### 4.1 控制器

```java
@Controller
@RequestMapping("/user")
public class UserController {

   @Autowired
   private UserService userService = null;

   // 展示用户详情
   @RequestMapping("/details")
   public ModelAndView details(Long id) {
      // 访问模型层得到数据
      User user = userService.getUser(id);
      // 模型和视图
      ModelAndView mv = new ModelAndView();
      // 定义模型视图
      mv.setViewName("user/details");
      // 加入数据模型
      mv.addObject("user", user);
      // 返回模型和视图
      return mv;
   }

   @RequestMapping("/detailsForJson")
   public ModelAndView detailsForJson(Long id) {
      // 访问模型层得到数据
      User user = userService.getUser(id);
      // 模型和视图
      ModelAndView mv = new ModelAndView();
      // 生成JSON视图
      MappingJackson2JsonView jsonView = new MappingJackson2JsonView();
      mv.setView(jsonView);
      // 加入模型
      mv.addObject("user", user);
      return mv;
   }

   @RequestMapping("/table")
   public ModelAndView table() {
      // 访问模型层得到数据
      List<User> userList = userService.findUsers(null, null);
      // 模型和视图
      ModelAndView mv = new ModelAndView();
      // 定义模型视图
      mv.setViewName("user/table");
      // 加入数据模型
      mv.addObject("userList", userList);
      // 返回模型和视图
      return mv;
   }

   @RequestMapping("/list")
   @ResponseBody
   public List<User> list(@RequestParam(value = "userName", required = false) String userName,
         @RequestParam(value = "note", required = false) String note) {
      // 访问模型层得到数据
      List<User> userList = userService.findUsers(userName, note);
      return userList;
   }
}
```

开发控制器首先是指定请求分支，这个任务是交由注解 @RequestMapping去完成的，这个注解可以标注类或者方法，当一个类被标注的时候，所有关于它的请求，都需要再@RequestMapping定义的URL下。当方法被标注后，也可以定义部分URL。配置了扫描路径之后，Spring MVC扫描机制就可以将其扫描，并且装载为HandlerMapping。

list方法，首先标注为@ResponseBody，这样Spring MVC就知道把结果转换为JSON。获取参数使用了@RequestParam，通过指定参数名成使得HTTP请求的参数和发给发的参数绑定，这个注解的默认规则是参数不能为空。

## 4. 深入Spring MVC 开发

#### 4.1 处理器映射

如果 Web 工程使用 Spring MV 那么它在启动阶段就会将注解RequestMapping 所配置的内容保存到处理器映射（HandlerMapping) 然后等待请求的到来，通过拦截请求信息与 HandlerMapping 行匹配，找到对应的处理器（它包含控制器处逻辑），并将处理器及其拦截器保存到HandlerExecutionChain 对象中，返回给 DispatcherServlet ，这样DispatcherServlet可以运行它们了。

![image-20200801143405272](https://gitee.com/wuugui/cloudimage/raw/master/java/springboot/image-20200801143405272.png)

![image-20200801143417330](https://gitee.com/wuugui/cloudimage/raw/master/java/springboot/image-20200801143417330.png)

可以通过配置项value或者path来设置请求URL，从而让对应的请求应黑色到控制器或其方法上。同时value和path可以通过正则是来让方法匹配多个请求。如果不是有必要，尽量不要这么做。**建议一个路径对应一个方法**

为了简化method配置项的配置。可以使用注解@GetMapping，@PutMapping，@PatchMapping，@PutMapping和@DeleteMapping。

### 4.2 获取控制器参数

处理器时堆控制器的包装，再处理器运行的过程中会调度控制器的方法，只是他在进入控制器方法之前按会对HTTP的参数和上下文进行解析，将他们转换为控制器所需的参数。这一步是处理器首先需要做的事。Spring提供了大量的转换规则，通过这些规则就能非常简单获取大部分参数 。

##### 4.2.1 在无注解下获取参数

在没有注解的情况下，Spring MVC也可以获取参数，且参数允许为空，唯一的要iu是参数名称和HTTP请求的参数名称一致。

```java
@GetMapping("/no/annotation")
@ResponseBody
public Map<String, Object> noAnnotation(Integer intVal, Long longVal, String str) {
	Map<String, Object> paramsMap = new HashMap<>();
	paramsMap.put("intVal", intVal);
	paramsMap.put("longVal", longVal);
	paramsMap.put("str", str);
	return paramsMap;
}
```
##### 4.2.2 使用@RequestParam获取参数

在前后端分离的驱使下，前端的迷宫明规则可能与后端的规则不同，这是需要报前端的参数与后端的对应起来。Spring MVC提供了注解@RequestParam来确定前后端参数名称的映射关系

```java
/**
 * 通过注解@RequestParam获取参数
 * 
 * @param intVal
 *            -- 整数
 * @param longVal
 *            -- 长整形
 * @param str
 *            --字符串
 * @return 响应JSON数据集
 */
@GetMapping("/annotation")
@ResponseBody
public Map<String, Object> requestParam(@RequestParam("int_val") Integer intVal,
		@RequestParam("long_val") Long longVal, @RequestParam("str_val") String strVal) {
	Map<String, Object> paramsMap = new HashMap<>();
	paramsMap.put("intVal", intVal);
	paramsMap.put("longVal", longVal);
	paramsMap.put("strVal", strVal);
	return paramsMap;
}
```
默认情况下@RequestParam标注的参数是蹦年为空的，为了让他能够为空，可以配置其属性required为false。

##### 4.2.3 传递数组

```java
@GetMapping("/requestArray")
@ResponseBody
public Map<String, Object> requestArray(int[] intArr, Long[] longArr, String[] strArr) {
    Map<String, Object> paramsMap = new HashMap<>();
    paramsMap.put("intArr", intArr);
    paramsMap.put("longArr", longArr);
    paramsMap.put("strArr", strArr);
    return paramsMap;
}
```

需要传递数组参数是，每个参数的数组元素只需要通过逗号分割即可。

http://localhost:8080/my/requestArray?intArr=1,2,3&longArr=4,5,6&strArr=str1,str2

##### 4.2.4 传递JSON

```java
@PostMapping("/insert")
@ResponseBody
public User insert(@RequestBody User user) {
   userService.insertUser(user);
   return user;
}
```

insert方法的参数标注为@RequestBody，意味着他将接受前端提交的JSON请求体，而在JOSN请求体与User类之间的睡醒名称是保持一致的，这样SprignMVC就会通过这层映射关系将JSON请求体转换为User对象。

##### 4.2.5 通过URL传递参数

REST风格网站，参数往往通过URL进行传递。例如获取编号为1的用户，URL 为/user/1。Spring MVC 可以通过处理器应黑色和注解@PathVariable的组合获取URL参数。首先通过处理器映射可以定位参数的位置和名称，而@PathVariable则可以通过名称来获取参数

```java
// {...}代表占位符，还可以配置参数名称
@GetMapping("/{id}")
// 响应为JSON数据集
@ResponseBody
// @PathVariable通过名称获取参数
public User get(@PathVariable("id") Long id) {
   return userService.getUser(id);
}
```

##### 4.2.6 获取格式化参数

格式化数据：货币、日期 yyyy-MM-dd。Spring MVC也提供了良好的支持。对日期和数字类型的转换注解进行处理，分别是 @DateTimeFormat 和 @NumberFormat

```java
// 获取提交参数
@PostMapping("/format/commit")
@ResponseBody
public Map<String, Object> format(Date date,
                                  @NumberFormat(pattern = "#,###.##") Double number) {
    Map<String, Object> dataMap = new HashMap<>();
    dataMap.put("date", date);
    dataMap.put("number", number);
    return dataMap;
}
```

添加配置

```properties
spring.mvc.format.date=yyyy-MM-dd
```

### 5. 自定义参数转换规则

#### 5.1 处理器获取参数逻辑

当请求到来时，在处理器执行的过程中，它首先会从HTTP请求和上下文环境来得到参数。如果是简单的参数他会以简单的转换器进行转换，而这些简单的转换器是Spring MVC自身已经提供了的。如果是转换HTTP请求体，他就会调用HttpMessageConverter接口的方法对请求的信息进行转换，首先他会先判断能否对请求实体进行转换，如果可以就会将其转换为Java类型。

![image-20200803094116710](https://gitee.com/wuugui/cloudimage/raw/master/java/springboot/image-20200803094116710.png)

HttpMessageConverter接口只是将HTTP的请求体转换为对应的Java对象。

**在Spring中，是通过WebDataBinder机制来获取参数的，他的主要作用是解析HTTP请求的上下文，然后在控制器的调用之前转换参数并且提供验证的功能，为调用控制器方法做准备。处理器会从HTTP请求中读取数据，然后通过三种接口来进行各类参数转换，者三种接口是Converter、Formatter和GenericConverter。**

Spring MVC的机制中这三种接口的实现类都采用了注册机的机制，默认的情况下Spring MVC已经在注册机内注册了许多的转换器，这样就可以实现大部分的数据类型转换。例如整形、长整形、字符串等参数。**当需要自定义转换规则时，只需要在注册机上注册转换器即可。**

![image-20200803095027439](https://gitee.com/wuugui/cloudimage/raw/master/java/springboot/image-20200803095027439.png)

控制器的参数是处理器通过Converter、Formatter和GenericConverter这三个接口转换出来的。

* Converter：一个普通的转换器。从HTTP对应的字符串转换为Integer类型
* Formatter：格式化转换器，类似于日期字符串就是通过它按照约定的格式转换为日期
* GenericConverter：将HTTP参数转换为数组

**Spring MVC提供了服务机制ConversionService接口管理数据类型转换，通常使用这个接口的子类DefaultFormattingConversionService对象来管理这些转换类。**

![image-20200803095823786](https://gitee.com/wuugui/cloudimage/raw/master/java/springboot/image-20200803095823786.png)

**在Spring Boot中提供了特殊的机制来管理这些转换器。Spring Boot的自动配置类WebMvcConfiguration还定义了内部类WebMvcAutoConfiguration-Adapter。**

![image-20200803100030326](https://gitee.com/wuugui/cloudimage/raw/master/java/springboot/image-20200803100030326.png)

子需要自定义Converter、Formatter和GenericConverter的接口的Bean，Spring Boot就会通过这个方法将他们注册到ConversionSErvice对象中。

#### 5.2 一对一转换器（Converter）

```java
@Component
public class StringToUserConverter implements Converter<String, User> {
    @Override
    public User convert(String userStr) {
        User user = new User();
        String []strArr = userStr.split("-");
        Long id = Long.parseLong(strArr[0]);
        String userName = strArr[1];
        String note = strArr[2];
        user.setId(id);
        user.setUserName(userName);
        user.setNote(note);
        return user;
    }
}
```

Converter接口的类型有原类型（S）和目标类型（T），通过convert转换。

```java
@GetMapping("/converter")
@ResponseBody
public User getUserByConverter(User user) {
   return user;
}
```

请求url

http://localhost:8080/user/converter?user=1-userName-note

#### 5.3 GenericConverter集合和数组转换

假若要增加多个用户，传递一个用户列表(List<User>)给控制器，此时Spring MVC会使用StringToCollectionConverter转换，这个类实现了GenericConverter接口，并且是Spring MVC内部已经注册的数组转换器。**首先会把字符串用逗号分割为一个个的子字符穿，然后根据原来行为String、目标乐星为User，找到对用的Converter进行转换。**已经定义了StringToUserConverter，这样就可以将字符串转换为User类。

```java
@GetMapping("/list")
@ResponseBody
public List<User> list(List<User> userList) {
   return userList;
}
```

http://localhost:8080/user/list?userList=1-userName1-note1,2-userName2-note2,3-userName3-note3

### 6. 数据验证

参数转换出来后，往往需要验证参数的合法性，因此Spring MVC提供了验证参数的机制。

#### 6.1 JSR-303 验证

JSR-303 验证主要通过注解方式进行。

验证POJO

```java
@Data
public class ValidatorPojo {

   // 非空判断
   @NotNull(message = "id不能为空")
   private Long id;

   @Future(message = "需要一个将来日期") // 只能是将来的日期
   // @Past //只能去过去的日期
   @DateTimeFormat(pattern = "yyyy-MM-dd") // 日期格式化转换
   @NotNull // 不能为空
   private Date date;

   @NotNull // 不能为空
   @DecimalMin(value = "0.1") // 最小值0.1元
   @DecimalMax(value = "10000.00") // 最大值10000元
   private Double doubleValue = null;

   @Min(value = 1, message = "最小值为1") // 最小值为1
   @Max(value = 88, message = "最大值为88") // 最大值88
   @NotNull // 不能为空
   private Integer integer;

   @Range(min = 1, max = 888, message = "范围为1至888") // 限定范围
   private Long range;

   // 邮箱验证
   @Email(message = "邮箱格式错误")
   private String email;

   @Size(min = 20, max = 30, message = "字符串长度要求20到30之间。")
   private String size;
}
```

```java
    @GetMapping("/valid/page")
    public String validPage() {
        return "/validator/pojo";
    }

    /***
     * 解析验证参数错误
     * @param vp —— 需要验证的POJO，使用注解@Valid 表示验证
     * @param errors  错误信息，它由Spring MVC通过验证POJO后自动填充
     * @return 错误信息Map
     */
    @RequestMapping(value = "/valid/validate")
    @ResponseBody
    public Map<String, Object> validate(
            @Valid @RequestBody ValidatorPojo vp, Errors errors) {
        Map<String, Object> errMap = new HashMap<>();
        // 获取错误列表
        List<ObjectError> oes = errors.getAllErrors();
        for (ObjectError oe : oes) {
            String key = null;
            String msg = null;
            // 字段错误
            if (oe instanceof FieldError) {
                FieldError fe = (FieldError) oe;
                key = fe.getField();// 获取错误验证字段名
            } else {
                // 非字段错误
                key = oe.getObjectName();// 获取验证对象名称
            }
            // 错误信息
            msg = oe.getDefaultMessage();
            errMap.put(key, msg);
        }
        return errMap;
    }
}
```

@Valid标识启动验证机制，他会自动地将最后的验证结果放入Errors对象中，这样就可以从中得到验证后的信息

#### 6.2 参数验证机制

WebDataBinder中处理可以注册转变换器，可可以注册验证其

**在Spring控制器中，允许使用注解@InitBinder，允许在进入控制器方法前修改WebDataBinder机制**。验证及接口Validator

![image-20200803104151484](https://gitee.com/wuugui/cloudimage/raw/master/java/springboot/image-20200803104151484.png)

自定义验证器

```java
public class UserValidator implements Validator {
   
   // 该验证器只是支持User类验证
   @Override
   public boolean supports(Class<?> clazz) {
      return clazz.equals(User.class);
   }

   // 验证逻辑
   @Override
   public void validate(Object target, Errors errors) {
      // 对象为空
      if (target == null) {
         // 直接在参数处报错，这样就不能进入控制器的方法了
         errors.rejectValue("", null, "用户不能为空");
         return;
      }
      // 强制转换
      User user = (User) target;
      // 用户名非空串
      if (StringUtils.isEmpty(user.getUserName())) {
         // 增加错误，可以进入控制器方法
         errors.rejectValue("userName", null, "用户名不能为空");
      }
   }
}
```

启用验证器

```java
/**
 * 调用控制器前先执行这个方法
 * 
 * @param binder
 */
@InitBinder
public void initBinder(WebDataBinder binder) {
   // 绑定验证器
   binder.setValidator(new UserValidator());
   // 定义日期参数格式，参数不再需注解@DateTimeFormat，boolean参数表示是否允许为空
   binder.registerCustomEditor(Date.class, new CustomDateEditor(new SimpleDateFormat("yyyy-MM-dd"), false));
}

/**
 * 
 * @param user
 *            -- 用户对象用StringToUserConverter转换
 * @param Errors
 *            --验证器返回的错误
 * @param date
 *            -- 因为WebDataBinder已经绑定了格式，所以不再需要注解
 * @return 各类数据
 */
@GetMapping("/validator")
@ResponseBody
public Map<String, Object> validator(@Valid User user, Errors Errors, Date date) {
   Map<String, Object> map = new HashMap<>();
   map.put("user", user);
   map.put("date", date);
   // 判断是否存在错误
   if (Errors.hasErrors()) {
      // 获取全部错误
      List<ObjectError> oes = Errors.getAllErrors();
      for (ObjectError oe : oes) {
         // 判定是否字段错误
         if (oe instanceof FieldError) {
            // 字段错误
            FieldError fe = (FieldError) oe;
            map.put(fe.getField(), fe.getDefaultMessage());
         } else {
            // 对象错误
            map.put(oe.getObjectName(), oe.getDefaultMessage());
         }
      }
   }
   return map;
}
```

initBinder方法使用@InitBinder，因此会在控制器方法前被执行，绑定自定义的验证器UserValidator，而且设置了日期的格式，所以在控制器方法中不再需要使用@DataTimeFormat定义日期格式化。@Valid标注User参数，Spring MVC会去遍历随影的验证其，当遍历到UserValidator时候，会执行supports方法。

验证，http://localhost:8080/user/validator?user=1--note&date=2018-1-1

### 7. 数据模型

数据模型的作用是绑定数据，为视图渲染做准备

![image-20200803111230246](https://gitee.com/wuugui/cloudimage/raw/master/java/springboot/image-20200803111230246.png)

如果在控制器方法参数中使用ModelAndView、Model或者ModelMap作为参数类型，Spring MVC会自动创建数据模型对象。

```java
@RequestMapping("/data")
@Controller
public class DataModelController {
    // 注入用户服务类
    @Autowired
    private UserService userService = null;
    
    // 测试Model接口
    @GetMapping("/model")
    public String useModel(Long id, Model model) {
        User user = userService.getUser(id);
        model.addAttribute("user", user);
        // 这里返回字符串，在Spring MVC中，会自动创建ModelAndView且绑定名称
        return "data/user";
    }
    
    // 测试modelMap类
    @GetMapping("/modelMap")
    public ModelAndView useModelMap(Long id, ModelMap modelMap) {
        User user = userService.getUser(id);
        ModelAndView mv = new ModelAndView();
        // 设置视图名称
        mv.setViewName("data/user");
        // 设置数据模型，此处modelMap并没有和mv绑定，这步系统会自动处理
        modelMap.put("user", user);
        return mv;
    }
    
    // 测试ModelAndView
    @GetMapping("/mav")
    public ModelAndView useModelAndView(Long id, ModelAndView mv) {
        User user = userService.getUser(id);
        // 设置数据模型
        mv.addObject("user", user);
        // 设置视图名称
        mv.setViewName("data/user");
        return mv;
    }
}
```

### 8. 视图和视图解析器

视图时渲染数据模型展示给用户的组件，在Spring MVC中分为逻辑视图和非逻辑视图。

* 逻辑视图：需要视图解析器（ViewResolver）进一步定位
* 非逻辑视图：不需要定位视图的位置，只需要直接将数据模型渲染出来即可，MappingJackson2JsonView

#### 8.1 视图设计

视图除了JSON和JSP视图之外，还有Excel、PDF等。他们都会实现Spring MVC定义的视图接口View

![image-20200803133027752](https://gitee.com/wuugui/cloudimage/raw/master/java/springboot/image-20200803133027752.png)

* getContentType：获取HTTP相应类型，返回的类型时文本、JSON数据集或者文件

* render：将数据模型渲染到视图，参数说明

  * model：数据模型，从控制器（或者由处理器自动绑定）返回的数据模型，这样render方法就可以把它渲染处来。大部分视图类由Spring MVC提供。只需要定义如何将数据模型渲染到视图中展示给用户即可。

    ![image-20200803133515533](https://gitee.com/wuugui/cloudimage/raw/master/java/springboot/image-20200803133515533.png)

    * MappingJakson2JsonView：会将数据模型渲染为Json数据及展示给用户查看
    * JstlView：是一个逻辑驶入，可以在控制器返回一个字符串，使用视图解析器去定位对应的JSP文件，就能找到对应的JSp文件，将数据模型传递进入，JstlView就会将数据模型渲染，展示数据给用户。
    * PDF和Execel视图等：只需要接受数据模型，然后通过自定义的渲染。

#### 8.2 视图实例-导出PDF文件

```java
public interface PdfExportService {
    public void make(Map<String, Object> model, Document document, PdfWriter writer,
                     HttpServletRequest request, HttpServletResponse response);
}
```

```java
public class PdfView extends AbstractPdfView {
    // 导出服务接口
    private PdfExportService pdfExportService = null;

    // 创建对象的时候载入导出服务接口
    public PdfView(PdfExportService pdfExportService) {
        this.pdfExportService = pdfExportService;
    }

    // 调用接口实现
    @Override
    protected void buildPdfDocument(Map<String, Object> model, Document document, PdfWriter writer,
                                    HttpServletRequest request, HttpServletResponse response) throws Exception {
        // 调用导出服务接口类
        pdfExportService.make(model, document, writer, request, response);
    }
}
```

在创建自定义PDF视图时候，需要自定义一个导出服务接口PdfExportService。通过实现这个接口，每个控制器都可以自定义其导出的逻辑。

```java
@GetMapping("/export/pdf")
public ModelAndView exportPdf(String userName, String note) {
    // 查询用户信息列表
    List<User> userList = userService.findUsers(userName, note);
    // 定义PDF视图
    View view = new PdfView(exportService());
    ModelAndView mv = new ModelAndView();
    // 设置视图
    mv.setView(view);
    // 加入数据模型
    mv.addObject("userList", userList);
    return mv;
}

private PdfExportService exportService() {
   // 使用Lambda表达式定义自定义导出
   return (model, document, writer, request, response) -> {
      try {
         // A4纸张
         document.setPageSize(PageSize.A4);
         // 标题
         document.addTitle("用户信息");
         // 换行
         document.add(new Chunk("\n"));
         // 表格，3列
         PdfPTable table = new PdfPTable(3);
         // 单元格
         PdfPCell cell = null;
         // 字体，定义为蓝色加粗
         Font f8 = new Font();
         f8.setColor(Color.BLUE);
         f8.setStyle(Font.BOLD);
         // 标题
         cell = new PdfPCell(new Paragraph("id", f8));
         // 居中对齐
         cell.setHorizontalAlignment(1);
         // 将单元格加入表格
         table.addCell(cell);
         cell = new PdfPCell(new Paragraph("user_name", f8));
         // 居中对齐
         cell.setHorizontalAlignment(1);
         table.addCell(cell);
         cell = new PdfPCell(new Paragraph("note", f8));
         cell.setHorizontalAlignment(1);
         table.addCell(cell);
         // 获取数据模型中的用户列表
         List<User> userList = (List<User>) model.get("userList");
         for (User user : userList) {
            document.add(new Chunk("\n"));
            cell = new PdfPCell(new Paragraph(user.getId() + ""));
            table.addCell(cell);
            cell = new PdfPCell(new Paragraph(user.getUserName()));
            table.addCell(cell);
            String note = user.getNote() == null ? "" : user.getNote();
            cell = new PdfPCell(new Paragraph(note));
            table.addCell(cell);
         }
         // 在文档中加入表格
         document.add(table);
      } catch (DocumentException e) {
         e.printStackTrace();
      }
   };
}
```

### 9. 文件上传

#### 9.1 Spring MVC对文件上传的支持

DispatcherServlet会使用适配器模式，将HttpServletRequest接口对象转换为MultipartHttpServletRequest对象，MultipartHttpServletRequest接口扩展了HttpServletRequest接口的所有方法，而且定义了一些操作文件的方法，通过这些方法实现对文件上传的操作。

![image-20200803140546351](https://gitee.com/wuugui/cloudimage/raw/master/java/springboot/image-20200803140546351.png)

在使用Spring MVC上传文件时，还需要配置MultipartHttpServletRequest，是通过MultipartResolver接口实现的。

![image-20200803140947214](https://gitee.com/wuugui/cloudimage/raw/master/java/springboot/image-20200803140947214.png)

在Spring Boot中，如果没有自定义MultipartResolver对象，会根据配置自动创建MultipartResolver对象，史记为StandardServletMultipartResolver。这样就能够将对上传的文件进行配置。

文件上传配置

```java
#是否启用Spring MVC多分文件上传功能
spring.servlet.multipart.enabled=true
spring.servlet.multipart.location=d:/springboot
#单个文件大小
spring.servlet.multipart.max-file-size=1
#所有文件大小
spring.servlet.multipart.max-request-size=20
#是否延迟多部件文件请求的参数和文件解析
spring.servlet.multipart.resolve-lazily=false
```

文件上传JSP

```jsp
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" 
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>文件上传</title>
</head>
    <body>
        <form method="post" 
                action="./part" enctype="multipart/form-data">
            <input type="file" name="file" value="请选择上传的文件" /> 
            <input type="submit" value="提交" />
        </form>
    </body>
</html>
```

```java
@Controller
@RequestMapping("/file")
public class FileController {
    /**
     * 打开文件上传请求页面
     * @return 指向JSP的字符串
     */
    @GetMapping("/upload/page")
    public String uploadPage() {
        return "/file/upload";
    }
    
    // 使用HttpServletRequest作为参数
    @PostMapping("/upload/request")
    @ResponseBody
    public Map<String, Object> uploadRequest(HttpServletRequest request) {
        boolean flag = false;
        MultipartHttpServletRequest mreq = null;
        // 强制转换为MultipartHttpServletRequest接口对象
        if (request instanceof MultipartHttpServletRequest) {
            mreq = (MultipartHttpServletRequest) request;
        } else {
            return dealResultMap(false, "上传失败");
        }
        // 获取MultipartFile文件信息
        MultipartFile mf = mreq.getFile("file");
        // 获取源文件名称
        String fileName = mf.getOriginalFilename();
        File file = new File(fileName);
        try {
            // 保存文件
            mf.transferTo(file);
        } catch (Exception e) {
            e.printStackTrace();
            return dealResultMap(false, "上传失败");
        } 
        return dealResultMap(true, "上传成功");
    }
    
    // 使用Spring MVC的MultipartFile类作为参数
    @PostMapping("/upload/multipart")
    @ResponseBody
    public Map<String, Object> uploadMultipartFile(MultipartFile file) {
        String fileName = file.getOriginalFilename();
        File dest = new File(fileName);
        try {
            file.transferTo(dest);
        } catch (Exception e) {
            e.printStackTrace();
            return dealResultMap(false, "上传失败");
        } 
        return dealResultMap(true, "上传成功");
    }
    
    @PostMapping("/upload/part")
    @ResponseBody
    public Map<String, Object> uploadPart(Part file) {
        // 获取提交文件名称
        String fileName = file.getSubmittedFileName();
        try {
            // 写入文件
            file.write(fileName);
        } catch (Exception e) {
            e.printStackTrace();
            return dealResultMap(false, "上传失败");
        } 
        return dealResultMap(true, "上传成功");
    }
    
    // 处理上传文件结果
    private Map<String, Object> dealResultMap(boolean success, String msg) {
        Map<String, Object> result = new HashMap<String, Object>();
        result.put("success", success);
        result.put("msg", msg);
        return result;
    }
}
```

### 10. 拦截器

当请求到达DispatcherServlet时，会更具HandlerMapping的机制找到处理器，这样就会返回一个HandlerExecutionChain对象，这个对象包含处理器和拦截器。这里的拦截器会对处理器进行拦截，这样就可以通过拦截器增加强处理的功能。

#### 10.1 拦截器的设计

所有拦截器都需要实现HandlerInterceptor接口。拦截器的执行错愕灰姑娘

![image-20200803150440762](https://gitee.com/wuugui/cloudimage/raw/master/java/springboot/image-20200803150440762.png)

#### 10.2 开发拦截器

```java
public class Interceptor1 implements HandlerInterceptor {
    @Override
    public boolean preHandle(HttpServletRequest request,
                             HttpServletResponse response, Object handler) throws Exception {
        System.out.println("处理器前方法");
        // 返回true，不会拦执行续的处理
        return true;
    }

    @Override
    public void postHandle(HttpServletRequest request,
                           HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
        System.out.println("处理器后方法");
    }

    @Override
    public void afterCompletion(HttpServletRequest request,
                                HttpServletResponse response, Object handler, Exception ex) throws Exception {
        System.out.println("处理器完成方法");
    }
}
```

注册拦截器。在配置文件中共实现WebMvcConfigurator接口，

```java
@Configuration
public class InterceptorConfig implements WebMvcConfigurer {

     @Override
     public void addInterceptors(InterceptorRegistry registry) {
      // 注册拦截器到Spring MVC机制，然后它会返回一个拦截器注册
      InterceptorRegistration ir = registry.addInterceptor(new Interceptor1());
      // 指定拦截匹配模式，限制拦截器拦截请求
      ir.addPathPatterns("/interceptor/*");
      }
}
```

指定了拦截模式，所以他只会拦截与正则式“/interceptor/*”匹配的请求

```java
@Controller
@RequestMapping("/interceptor")
public class InterceptorController {
   @GetMapping("/start")
   public String start() {
      System.out.println("执行处理器逻辑");
      return "/welcome";
   }
}
```