# 结构化并发程序

## 任务执行

### 概念

- 任务通常时一些抽象的且离散的工作单元

### 在线程中执行任务

- 设计

	- 理想情况下各个任务是相互独立的：任务并不依赖于其他任务的状态、结果或边界效应

		- 独立性有助于实现并发

	- 以独立的客户端请求为边界

- 串行地执行任务

	- 服务器应用程序中，穿行处理机制通常都无法提供高吞吐率或快速响应

- 显式地为任务创建线程

	- 为每个线程创建一个新线程提供服务

		- 能够提升串行执行的性能，只要请求到达速率不超过服务器请求处理能力，这种发发可以同时带来更快的响应性和更高的吞吐率

- 无限创建线程的不足

	- 线程生命周期开销非常高

		- 线程的创建需要消耗大量的计算资源

	- 资源消耗

		- 活跃线程会消耗系统资源，大量的空闲线程会占用许多内存，给垃圾回收器带来压力，而大量的线程在竞争CPU资源时还将产生其他性能开销。

	- 稳定性

		- 可创建线程数量存在限制

			- 一定范围内增加线程可以提高系统的吞吐率，但超过这个范围，在创建更多的线程只会降低程序的执行速度。

### Executor框架

- 概念

	- 任务是一组逻辑工作单元，而线程则是使任务异步执行的机制。Executor童工了一种标准的方法将任务的提交过程与执行过程解耦开来，并用Runable来表示任务
	- Executor基于生产者-消费者模式，提交任务的操作相当于生产者，执行任务的线程相当于消费者

- 基于Executor的Web服务器

	- 基于线程池

	  /**
	   * 基于线程池的服务器
	   * */
	  public class TaskExecutionWebServer {
	      private static final int NTHREADS = 100;
	      private static final Executor exec = Executors.newFixedThreadPool(NTHREADS);
	  
	      public static void main(String[] args) throws IOException {
	          ServerSocket serverSocket = new ServerSocket(8080);
	          while (true) {
	              Socket socket = serverSocket.accept();
	              Runnable runnable = new Runnable() {
	                  @Override
	                  public void run() {
	                      handleRequest(socket);
	                  }
	              };
	  
	              exec.execute(runnable);
	          }
	      }
	  
	      private static void handleRequest(Socket socket) {
	  
	      }
	  }

	- 每个请求创建单独线程

	  public class ThreadPerTaskExecutor implements Executor {
	      @Override
	      public void execute(Runnable command) {
	          new  Thread(command).start();
	      }
	  }

	- 以同步方式执行所有任务

	  class WithinThreadExecutor implements Executor
	  {
	      @Override
	      public void execute(Runnable command) {
	          command.run();
	      }
	  }

- 执行策略

	- 考虑使用Executor来代替Thread

- 线程池

	- 管理一组同构工作线程的资源池。与工作队列密切相关，工作队列中共保存了所有等待执行的任务。工作者线程从任务队列中获取一个任务，执行任务，然后返回线程池并等待下一个任务
	- 优点

		- 通过重用现有的线程而不是拆功能键新的线程，可以在处理多个请求时分摊在线程创建和销毁过程中产生的巨大开销。
		- 当请求到达时工作线程已经存在，因此不会由于等待创建线程而延迟任务的执行，从而提高了响应性。
		- 通过适当调整线程池的大小，可以创建足够多的线程以便使处理器保持忙碌状态，同时还可以防止过多线程相互竞争资源而使应用程序耗尽内存或失败。

	- Executors创建线程池

		- newFixedThreadPool

			- 创建固定长度的线程池，每当提交一个任务时就创建一个线程，直到达到线程池的最大数量，这时线程池的规模不再变化。如果某个线程由于发生位于其的Exception而计数，那么线程池会补充一个新线程

		- newCachedThreadPool

			- 创建一个可缓存的线程池，如果线程池的当前规模超过了处理需求时，那么将回收空闲的线程，当需求增加时，则可以添加新的线程，线程池的规模不存在任何限制

		- newSingleThreadPool

			- 创建单个工作者线程来执行任务，如果这个线程异常结束，会创建另一个线程来替代。能够确保依照任务再队列中的顺序来串行执行

		- newScheduledThreadPool

			- 创建一个固定长度的线程池，而且以延迟或定时的方式来执行任务，类似Timer

- Executor的生命周期

	- 由于Executor以异步方式来执行任务，因此在任何时刻，之前提交任务的状态不是立即可见的。有些任务可能已经完成，有些可能正在运行，而其他的任务可能在队列中共等待执行

		- 当关闭应用程序时，可能采用最平缓的关闭形式（完成所以头已经启动的任务，并且不再接受任何新的任务），也可能采用最粗暴的关闭形式（直接关掉机房的电源），以及其他各种可能的形式

	- ExecutorService

		- Executor扩展ExecutorService接口，扩展了生命周期管理方法

		  public interface ExecutorService extends Executor {
		      void shutdown();
		      List<Runnable> shutdownNow();
		      boolean isShutdown();
		      boolean isTerminated();
		  
		      boolean awaitTermination(long timeout, TimeUnit unit)
		              throws InterruptedException;
		  
		      <T> Future<T> submit(Callable<T> task);
		      <T> Future<T> submit(Runnable task, T result);
		      Future<?> submit(Runnable task);
		      <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks) throws InterruptedException;
		      <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)
		              throws InterruptedException;
		      <T> T invokeAny(Collection<? extends Callable<T>> tasks) throws InterruptedException, ExecutionException;
		      <T> T invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)
		              throws InterruptedException, ExecutionException, TimeoutException;
		  }

		- ExecutorService生命周期有三种状态：运行、关闭和已停止。在初始化创建时处于运行状态。

			- shutdown方法将执行平缓的关闭过程 ：不再接受新的任务，同时等待已经提交的任务执行完成（包含未开始执行的任务）
			- shutdownNow方法将执行粗暴的关闭：他将常识取消所有运行中的任务，并且不在启动队列中尚未开始执行的任务

		- 在ExecutorService关闭后提交的任务将由“拒绝执行处理器（Rejected Execution Handler）”来处理，它会抛出未检查的RejectedExecutionException
		- 等所有任务都完成后，ExecutorService将转入终止状态。可以调用awaitTermination来等待ExecutorService到达终止状态，或者通过调用isTerminated来轮询是否已经终止。通常在调用awaitTermination之后会立即调用shutdown，从而产生同步地关闭ExecutorService的效果

		  public class LifecycleWebService {
		      private final ExecutorService executorService = null; //new AbstractExecutorService() {
		  
		      public void start() throws IOException {
		          ServerSocket socket = new ServerSocket(8080);
		          while (!executorService.isShutdown()) {
		              try {
		                  Socket socket1 = socket.accept();
		                  executorService.execute(new Runnable() {
		                      @Override
		                      public void run() {
		                          handleRequest(socket1);
		                      }
		                  });
		              } catch (RejectedExecutionException e) {
		                  if (!executorService.isShutdown()) {
		                  }
		              }
		          }
		      }
		  
		      public void stop() {
		          executorService.shutdown();
		      }
		  
		      private void handleRequest(Socket socket) {
		  
		      }
		  }

- 延迟任务与周期任务

	- Timer

		- Timer类负责管理延迟任务以及周期任务。由于Timer存在一些缺陷。考虑使用ScheduledThreadPoolExecutor来代替它。可通过ScheduledThreadPoolExecutor的构造函数或者newScheduledThreadPool工厂方法创建

			- Timer再执行所有定时任务时只会创建一个线程。如果某个任务的执行时间过长，那么将破坏其他TImerTask的定时精确性。
			- 如果TimerTask抛出一个未检查的异常，由于Timer线程并不捕获异常，因此将终止定时线程。已经调度但尚未执行的TImerTask也不会执行，新任务也不会被调度。

		- DelayQueue

### 找出可利用的并行性

- 网页渲染中的并行性

	- 串行

	  public class SingleThreadRenderer {
	      void renderPage(CharSequence sequence) {
	          List<ImageData> imageData = new ArrayList<>();
	          for (ImageInfo:
	               imageInfo:
	               scanForImageInfo(sequence)) {
	              imageData.add(imageInfo.downloadImage());
	              ;
	              for (ImageData data : imageData) {
	                  renderImage(data);
	              }
	          }
	      }
	  }

	- 携带结果的任务Callable与Future

		- Executor使用Runnable作为基本的任务表现形式。Runnable虽然run能写入到日志文件或者将结果放入某个共享的数据结构，但是不能返回一个值或抛出一个受检查的异常
		- 许多任务实际上都是存在延迟的计算（执行数据库查询，从网上获取数据），对于这些任务Callable是一种更好的抽象：它认为主入口点将返回一个值或者抛出一个异常
		- Future表示一个任务的生命周期，并提供了相应的方法来判断是否已经完成或者取消，以及获取任务的结果和取消任务等。任务只能前景不能后退

		  public class FutureRenderer {
		      private final ExecutorService executorService = Executors.newFixedThreadPool(10);
		  
		      public void renderPage(CharSequence sequence) throws Throwable {
		          final List<ImageInfo> imageInfos = scanForImageInfo(sequence);
		  
		          Callable<List<ImageData>> callable = new Callable<List<ImageData>>() {
		              @Override
		              public List<ImageData> call() throws Exception {
		                  List<ImageData> imageData = new ArrayList<>();
		                  for (ImageInfo imageInfo : imageInfos) {
		                      imageData.add(imageInfo.downloadImage());
		                  }
		                  return imageData;
		              }
		          };
		  
		          Future<List<ImageData>> future = executorService.submit(callable);
		  
		          renderText(sequence);
		  
		          try {
		  
		              List<ImageData> result = future.get();
		              for (ImageData imageData : result) {
		                  renderImage(imageData);
		              }
		          } catch (ExecutionException e) {
		              throw e.getCause();
		          } catch (InterruptedException e) {
		              Thread.currentThread().interrupt();
		              future.cancel(true);
		          }
		      }
		  
		      private List<ImageInfo> scanForImageInfo(CharSequence sequence) {
		          return new ArrayList<>();
		      }
		  
		      private void renderText(CharSequence sequence) {
		      }
		  
		      private void renderImage(ImageData data) {
		      }
		  }

			- get方法的行为取决于任务的状态，任务已完成get会立即返回或者抛出异常。如果没完成将阻塞并知道任务完成。如果任务抛出异常，那么get将异常封装为ExecutionException并重新抛出，如果任务被取消，那么get将抛出CancellationExeception。ExecutionException可以通过getCause来获得封装的初始异常。
			- ExecutorService中的所有submit方法都将返回一个Future，从而将一个Runnable或Callable提交给Executor，得到一个Future用来获得人物的执行结果或者取消任务

- 异构任务并行化中存在的局限

	- 网页渲染例子中，下载与渲染，当渲染文本速度远远高于下载图像的速度，那么程序的最终性能与串行执行时的性能差不多，而代码却变得更复杂了
	- 只有当大量独立且同构的任务可以并发进行处理时，才能体现出将程序的工作负载分配到多个任务中带来真正的性能提升。

- CompletionService

	- CompletionService将Executor和BlockingQueue的功能融合再一起，可以将callable任务交给他来执行没然后使用类似于队列操作的take和poll等方法来获得已经完成的结果，这些结果会在完成时封装为Future

	  public class Renderer {
	      private final ExecutorService executorService = Executors.newCachedThreadPool();
	  
	  
	      void renderPage(CharSequence sequence) {
	  
	          List<ImageInfo> imageInfos = scanForImageInfo(sequence);
	  
	          CompletionService<ImageData> completionService = new ExecutorCompletionService<>(executorService);
	          for (ImageInfo imageInfo : imageInfos) {
	              completionService.submit(new Callable<ImageData>() {
	                  @Override
	                  public ImageData call() throws Exception {
	                      return imageInfo.downloadImage();
	                  }
	              });
	          }
	  
	          renderText(sequence);
	  
	          try {
	              for (int i = 0; i < imageInfos.size(); i++) {
	                  Future<ImageData> futureTask = completionService.take();
	                  ImageData data = futureTask.get();
	                  renderImage(data);
	              }
	          } catch (InterruptedException e) {
	              Thread.currentThread().interrupt();
	          } catch (ExecutionException e) {
	              launderThrowable(e.getCause());
	          }
	      }
	  
	      private List<ImageInfo> scanForImageInfo(CharSequence sequence) {
	          return new ArrayList<>();
	      }
	  
	      private void renderText(CharSequence sequence) {
	      }
	  
	      private void renderImage(ImageData data) {
	      }
	  
	      public static RuntimeException launderThrowable(Throwable t) {
	          if (t instanceof RuntimeException) {
	              return (RuntimeException) t;
	          } else if (t instanceof Error) {
	              throw (Error) t;
	          } else {
	              throw new IllegalStateException("Not unchecked", t);
	          }
	      }
	  }

- 为任务设置时限

	- 在是哟共时限任务时需要注意，当这些任务超时后应该立即停止，从而避免为继续计算一个不再使用的结果而浪费计算资源。

		- 如果一个限时的get方法抛出TimeoutException，那么可以通过Future来取消任务。

		  public class FutureRenderer {
		      private final ExecutorService executorService = Executors.newFixedThreadPool(10);
		  
		      public void renderPage(CharSequence sequence) throws Throwable {
		          final List<ImageInfo> imageInfos = scanForImageInfo(sequence);
		  
		          Callable<List<ImageData>> callable = new Callable<List<ImageData>>() {
		              @Override
		              public List<ImageData> call() throws Exception {
		                  List<ImageData> imageData = new ArrayList<>();
		                  for (ImageInfo imageInfo : imageInfos) {
		                      imageData.add(imageInfo.downloadImage());
		                  }
		                  return imageData;
		              }
		          };
		  
		          Future<List<ImageData>> future = executorService.submit(callable);
		  
		          renderText(sequence);
		  
		          try {
		  
		              List<ImageData> result = future.get(100, TimeUnit.SECONDS);
		              for (ImageData imageData : result) {
		                  renderImage(imageData);
		              }
		          } catch (ExecutionException e) {
		              throw launderThrowable(e.getCause());
		          } catch (InterruptedException e) {
		              Thread.currentThread().interrupt();
		              future.cancel(true);
		          }
		          catch (TimeoutException e)
		          {
		              future.cancel(true);
		          }
		      }
		  
		      private List<ImageInfo> scanForImageInfo(CharSequence sequence) {
		          return new ArrayList<>();
		      }
		  
		      private void renderText(CharSequence sequence) {
		      }
		  
		      private void renderImage(ImageData data) {
		      }
		  
		      public static RuntimeException launderThrowable(Throwable t) {
		          if (t instanceof RuntimeException) {
		              return (RuntimeException) t;
		          } else if (t instanceof Error) {
		              throw (Error) t;
		          } else {
		              throw new IllegalStateException("Not unchecked", t);
		          }
		      }
		  }

	- invokAll将多个任务提交到一个ExecutorService并获得结果，InvokeAll方法的参数为一组任务，并返回一组Future。这两个集合有相同的结构。invokeAll按照任务集合中迭代器的顺序将所有的Future添加到返回的集合中。从而时调用者能将各个Future与其表示的Callable关联起来。当所有的任务执行完毕时，任何还未完成的任务都会取消。当InvokeAll返回，每个任务要么正常完成，要么被取消，可以调用get或isCancelled派判断

	  class TraveQuote {
	  }
	  
	  class TravelCompany {
	  }
	  
	  class TravelInfo {
	  }
	  
	  public class QuoteTask implements Callable<TraveQuote> {
	      private final TravelCompany company;
	      private final TravelInfo travelInfo;
	  
	      public QuoteTask() {
	          company = new TravelCompany();
	          travelInfo = new TravelInfo();
	      }
	  
	      public QuoteTask(TravelCompany company, TravelInfo info) {
	          this.company = company;
	          travelInfo = info;
	      }
	  
	      public TraveQuote timeout() {
	          return new TraveQuote();
	      }
	  
	      @Override
	      public TraveQuote call() throws Exception {
	          return new TraveQuote();
	      }
	  
	      public List<TraveQuote> getRankedTravelQuotes(ExecutorService executor, TravelInfo travelInfo, Set<TravelCompany> companies,
	                                                    Comparator<TraveQuote> ranking, long time, TimeUnit timeUnit) throws InterruptedException {
	          List<QuoteTask> tasks = new ArrayList<>();
	          for (TravelCompany company : companies) {
	              tasks.add(new QuoteTask(company, travelInfo));
	          }
	  
	          List<Future<TraveQuote>> futures = executor.invokeAll(tasks);
	  
	          List<TraveQuote> quotes = new ArrayList<>(tasks.size());
	  
	          Iterator<QuoteTask> taskIterator = tasks.iterator();
	          for (Future<TraveQuote> future : futures) {
	              QuoteTask task = taskIterator.next();
	              try {
	                  quotes.add(future.get());
	              } catch (ExecutionException e) {
	                  e.printStackTrace();
	              } catch (CancellationException e) {
	                  quotes.add(task.timeout());
	              }
	          }
	  
	          Collections.sort(quotes, ranking);
	          return quotes;
	      }
	  }

## 取消与关闭

### 前提

- 要使任务和线程安全、快速、可靠地停止下来不容易，Java没有提供任何机制来安全地终止另一个线程的当前工作。但提供了中断这种协作机制

### 1、任务取消

- 取消类型

	- 用户请求取消、有时间限制的操作、应用程序事件、错误、关闭

- 协作机制

	- 设置某个“已请求取消”标致，任务定期查看该标志，如果设置了这个标志，任务提前结束

		- PrimeGenerator

		  public class CancellThread {
		  
		      public static void main(String[] args) {
		          PrimeGenerator generator = new PrimeGenerator();
		          Thread thread = new Thread(generator);
		          thread.start();
		  
		          try {
		              Thread.sleep(1000);
		  
		          } catch (Exception e) {
		  
		          } finally {
		              generator.cancel();
		          }
		  
		          System.out.println(generator.getPrimes());
		      }
		  }
		  
		  class PrimeGenerator implements Runnable {
		      private final List<BigInteger> primes = new ArrayList<>();
		      private volatile boolean cancelled;
		  
		      @Override
		      public void run() {
		          BigInteger p = BigInteger.ONE;
		          while ((!cancelled)) {
		              p = p.nextProbablePrime();
		              synchronized (this) {
		                  primes.add(p);
		              }
		          }
		      }
		  
		      public void cancel() {
		          cancelled = true;
		      }
		  
		      public synchronized List<BigInteger> getPrimes() {
		          return new ArrayList<>(primes);
		      }
		  }

- 中断

	- PrimeGenerator存在问题，如果当产生的数据的方法调用了一个阻塞方法（BlockingQueue.put）那么会产生严重的问题，任务可能永远不会检查取消标志，因此不会结束。
	- 并不会真正地中断一个正在运行的线程，而是发出中断请求，然后由线程在下一个合适的时刻中断自己。

		- 如果在调用interrupted时返回了true，那么除非你想屏蔽这个中断，否则必须对他处理，可以抛出InterruptedException，或者通过再次调用interrupt来恢复中断

		  public class InterruptThreade {
		      public static void main(String[] args) {
		  
		          ArrayBlockingQueue<BigInteger> arrayBlockingQueue = new ArrayBlockingQueue<>(100);
		  
		          PrimeGenerator1 generator = new PrimeGenerator1(arrayBlockingQueue);
		          Thread thread = new Thread(generator);
		          thread.start();
		  
		          try {
		              Thread.sleep(1000);
		  
		          } catch (Exception e) {
		  
		          } finally {
		              generator.cancel();
		          }
		      }
		  }
		  
		  class PrimeGenerator1 implements Runnable {
		      private final BlockingQueue<BigInteger> primes;
		      private volatile boolean cancelled;
		  
		      public PrimeGenerator1(BlockingQueue<BigInteger> queue) {
		          this.primes = queue;
		      }
		  
		      @Override
		      public void run() {
		          BigInteger p = BigInteger.ONE;
		          try {
		              while ((!Thread.currentThread().isInterrupted())) {
		                  primes.put(p.nextProbablePrime());
		              }
		          } catch (InterruptedException e) {
		              Thread.currentThread().interrupt();
		          }
		  
		      }
		  
		      public void cancel() {
		          Thread.currentThread().interrupt();
		      }
		  }

- 中断策略

	- 中断策略规定线程如何解释某个中断请求，当发现中断请求时，应该做哪些工作，哪些工作单元对于中断来说是原子操作，以及以多块的速度来响应中断。
	- 最合理的终端策略是某种形式的线程级取消操作或服务级取消操作：尽快退出，在必要时进行清理，通知某个所有者该线程已经退出。

		- 区分任务和线程对于中断的反应时很重要的 ，一个中断请求可以有一个或多个接收者----中断线程池种的某个工作者线程，同时意味着“取消当前任务”和“关闭工作者线程”
		- 任务不会再其自己拥有的线程中执行，而是在某个服务拥有的线程中执行
		- 当检查到中断请求，任务不需要放弃所有操作，它可以推迟处理中断请求，并直到某个更合适的时刻。因此需要记住中断请求，并在完成当前任务后抛出InterruptException或者表示已收到中断请求
		- 任务不应该对执行该任务的线程的终端策略做出任何假设，除非该任务被专门设计为在服务中运行，并且在这些服务中包含特定的中断策略。无论任务把中断视为取消，还是其他某个中断响应操作，都应该小心地保存执行线程的中断状态。如果处理将InterruptedException传递给调用者外还需要执行其他操作，那么应该在捕获InterruptedException之后恢复中断状态：Thread.currentThread().interrupt();

- 响应中断

	- 策略

		- 传递异常

		  public BigInteger getNextInteger() throws InterruptedException {
		      return primes.take();
		  }

		- 恢复中断状态

			- 通过再次调用interrupt来恢复中断状态。不能屏蔽InterruptException
			- 只有实现了线程中断策略的代码才可以屏蔽中断请求。在常规的任务和库代码中都不应该屏蔽中断请求
			- 对于一些不支持取消但仍可调用中断阻塞方法的操作，他们必须在循环中调用这些方法，并在发现中断后重新常识。这种情况下应该在本地保存中断状态，并在返回前恢复状态而不是在捕获InterreptedExeception时恢复状态。

			  public BigInteger getNextInteger() throws InterruptedException {
			      boolean isInterrupted = false;
			  
			      try {
			          while (true) {
			              try {
			                  return primes.take();
			              } catch (InterruptedException exception) {
			                  isInterrupted = true;
			              }
			  
			          }
			      } finally {
			          if (isInterrupted) {
			              Thread.currentThread().interrupt();
			          }
			      }
			  }

	- 如果代码不会调用可中断的阻塞方法，那么仍然可以通过在任务代码中轮询当前线程的中断状态来响应中断。要选择合适的轮询频率，就需要在效率和响应性之前进行权衡。如果响应性要求高，那么就不应该调用哪些执行时间较长并且不响应中断的方法。

- 通过Future来实现取消

  private static ExecutorService executorService;
  
  public static void timeRun(Runnable runnable, long timeout, TimeUnit timeUnit) throws Throwable {
      Future<?> future = executorService.submit(runnable);
      try {
          future.get(timeout, timeUnit);
      } catch (TimeoutException e) {
  
      } catch (ExecutionException e) {
          throw e.getCause();
      } finally {
          //如果任务正在运行将被中断
          future.cancel(true);
      }
  }

- 处理不可中断的阻塞

	- 许多可阻塞的方法都是通过提前返回或者抛出InterruptedException来响应中断请求的
	- 不可中断操作而被阻塞

		- Java.io包中同步Socket I/O

			- 虽然inputstream和outputstream中的read和write等方法都不会响应中断，单通过关闭底层的套接字，可以使得由于执行read或write等方法而被阻塞的线程抛出SocketException

		- Java.io包中的同步I/O

			- 当中断一个正在InterruptiableChannel上等待线程时，将抛出ClosedByInterruptException并关闭链路。当关闭一个InterruptiableChannel时，将导致所有在链路上阻塞的线程都抛出AsyncChronousCloseException。

		- Selector的异步I/O

			- 如果一个线程在调用Selector.select方法时被阻塞，当调用close或wakeup方法会使线程抛出ClosedSelectorException并提前返回

		- 获取某个锁

			- 如果一个线程由于等待某个内置锁而阻塞，那么将无法响应中断。Lock中提供了lockinterruptibly方法，该方法允许在等待一个锁的同时仍能响应中断

	- 通过改写interrupt方法将非标准的取消操作封装在Thread中

	  public class ReaderThread extends Thread {
	      private final Socket socket;
	      private final InputStream inputStream;
	  
	  public class ReaderThread extends Thread {
	      private final Socket socket;
	      private final InputStream inputStream;
	  
	      public ReaderThread(Socket socket) throws IOException {
	          this.socket = socket;
	          this.inputStream = socket.getInputStream();
	      }
	  
	      @Override
	      public void interrupt() {
	          try {
	              socket.close();
	          } catch (IOException e) {
	          } finally {
	              super.interrupt();
	          }
	      }
	  
	      @Override
	      public void run() {
	          try {
	              byte[] buf = new byte[1024];
	              while (true) {
	                  int count = inputStream.read(buf);
	                  if (count < 0) {
	                      break;
	                  } else if (count > 0) {
	                  }
	              }
	          } catch (IOException e) {
	              //允许线程退出
	          }
	      }
	  }

- 采用newTaskFor来封装非标准的取消

  interface CancellableTask<T> extends Callable<T> {
      void cancel();
  
      RunnableFuture<T> newTask();
  }
  
  
  class CancellingExecutor extends ThreadPoolExecutor {
      public CancellingExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue) {
          super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);
      }
  
      @Override
      protected <T> RunnableFuture<T> newTaskFor(Callable<T> callable) {
          if (callable instanceof CancellingExecutor) {
              return ((CancellableTask<T>) callable).newTask();
          } else {
              return super.newTaskFor(callable);
          }
      }
  }
  
  public abstract class SocketUsingTask<T> implements CancellableTask<T> {
      private Socket socket;
  
      @Override
      public synchronized void cancel() {
          try {
              if (socket != null) {
                  socket.close();
              }
          } catch (IOException exception) {
          }
      }
  
      public RunnableFuture<T> newTaskFor(Callable<T> callable) {
          return new FutureTask<T>(this) {
              @Override
              public boolean cancel(boolean mayInterruptIfRunning) {
                  try {
                      SocketUsingTask.this.cancel();
                  } finally {
                      return super.cancel(mayInterruptIfRunning);
                  }
              }
          };
      }
  }

	- 如果SocketUsingTask通过自己的Future来取消，那么底层的套接字将被关闭并且线程将被中断。因此它提高了任务对取消操作的响应性：不仅能够在调用可中断方法的同时确保响应取消操作，而且还能掉员工可阻塞的套接字I/O方法

### 2、停止基于线程的服务

- 应用程序通常会创建拥有多个线程的服务，例如线程池，并且这些服务的生命周期通常比创建他们的方法的生命周期更长。如果应用程序准备退出，那么这些服务所拥有的线程也需要结束，由于无法通过抢占式的方式来停止线程，因此他们需要自行结束。

	- 除非拥有某个线程，否则不能对该线程进行操作。线程有一个相应的所有者，即创建该线程的类。因此线程池是其工作者线程的所有者，如果要中断这些线程，那么应该使用线程池。
	- 线程的所有权是不可传递的：应用程序可以拥有服务，服务也可以拥有工作者线程，但应用程序并不能拥有工作者线程，因此应用程序不能直接停止工作者线程。相反服务应该提供生命周期方法来关闭它自己以及它所拥有的线程。这样应用程序关闭该服务时，服务就可以关闭所有的线程了。
	- 对于持有线程的服务，只要服务的存在时间大于创建线程的方法的存在时间，那么就应该提供生命周期方法

		- ExecutorService中提供了shutdown和shutdownNow等方法。同样在其他拥有线程的服务中也应该提供类似的关闭机制

- logger实例

  public class LogService {
      private final BlockingQueue<String> queue;
      private final LoggerThread logger;
      private boolean isShotdown;
      private int reservations;
  
  
      public LogService(Writer writer) {
          isShotdown = false;
          reservations = 0;
          queue = new LinkedBlockingDeque<>(10000);
          logger = new LoggerThread((PrintWriter) writer);
      }
  
      public void start() {
          logger.start();
      }
  
      public void stop() {
          synchronized (this) {
              isShotdown = true;
          }
          logger.interrupt();
      }
  
      public void log(String msg) throws InterruptedException {
          synchronized (this) {
              if (isShotdown) {
                  throw new InterruptedException("logger is shot down");
              }
              ++reservations;
          }
          queue.put(msg);
      }
  
  
      private class LoggerThread extends Thread {
          private final PrintWriter writer;
  
          public LoggerThread(PrintWriter writer) {
              this.writer = writer;
          }
  
          @Override
          public void run() {
              try {
                  while (true) {
                      synchronized (LogService.this) {
                          //收到关闭请求后将所有消息写入日志，并解除所有在调用log时阻塞的生产者
                          if (isShotdown && reservations == 0) {
                              break;
                          }
                      }
                      synchronized (this) {
                          reservations--;
                      }
                      writer.println(queue.take());
                  }
              } catch (InterruptedException e) {
              } finally {
                  writer.close();
              }
          }
      }
  }

- 关闭ExecutorService

	- shutdown

		- 关闭速度慢，但是更安全。ExecutorService会等到队列中的所有任务都执行完毕后才关闭

	- shutdownNow

		- 速度更快，风险也更大，因为任务很可能在执行到一半时时被结束。

	- logger实例

	  class LoggerService {
	      private final ExecutorService executorService = Executors.newSingleThreadExecutor();
	      private final PrintWriter writer;
	  
	      public LoggerService(PrintWriter writer) {
	          this.writer = writer;
	      }
	  
	      public void start() {
	      }
	  
	      public void stop() {
	          try {
	              executorService.shutdown();
	              executorService.awaitTermination(5, TimeUnit.SECONDS);
	          } catch (InterruptedException e) {
	          } finally {
	          }
	      }
	  
	      public void log(String msg) {
	          executorService.execute(new WriteTask(msg));
	      }
	  
	      class WriteTask implements Runnable {
	          private final String msg;
	  
	          public WriteTask(String msg) {
	              this.msg = msg;
	          }
	  
	          @Override
	          public void run() {
	              writer.println(msg);
	          }
	      }
	  }

- “毒丸”对象

  public class IndexService {
      private static final File POSION = new File("");
      private final BlockingQueue<File> queue;
      private final FileFilter fileFilter;
      private final File root;
  
      private final CrawlerThread crawlerThread = new CrawlerThread();
      private final IndexThread indexThread = new IndexThread();
  
      public IndexService() {
          queue = new LinkedBlockingDeque<>();
          root = new File("c:");
          fileFilter = null;
      }
  
  
      class CrawlerThread extends Thread {
          @Override
          public void run() {
              try {
                  craw(root);
  
              } catch (InterruptedException exception) {
              } finally {
                  while (true) {
                      try {
                          queue.put(POSION);
                          break;
                      } catch (InterruptedException e) {
  
                      }
                  }
              }
          }
  
          private void craw(File root) throws InterruptedException {
          }
      }
  
      class IndexThread extends Thread {
          @Override
          public void run() {
  
              try {
                  while (true) {
                      File file = queue.take();
                      if (file == POSION) {
                          break;
                      } else {
                          index(file);
                      }
                  }
              } catch (InterruptedException e) {
  
              }
          }
  
          private void index(File file) {
  
          }
      }
  }

	- “毒丸”：一个放在队列上的对象，含义是“当得到这个对象时，立即停止。”在FIFO队列中，毒丸对象将确保消费者在关闭之前首先完成队列中的所有工作，在提交毒丸对象之前提交后将不会再提交任何工作
	- 只有在生产者和消费者的数量都已知的情况下，才可以使用毒丸对象。当生产者和消费者数量较大时，这种方法将变得难以使用。只有在无界队列中，毒丸对象才能可靠地工作

- shutdownNow的局限性

	- 当通过shutdownNow来强行关闭ExecutorService时，它会尝试取消正在执行的任务，并返回所有已提交但是尚未开始的任务，从而将这些任务写入日志或者保存起来以便之后进行处理
	- 要知道哪些任务还没有完成，不仅需要直到哪些任务还没开始，而且还需要直到Executor关闭时哪些任务正在执行

		- 找出已经开始还没正常完成的任务

		  public class ShutdownNowDemo extends AbstractExecutorService {
		  
		      private final ExecutorService executorService = Executors.newCachedThreadPool();
		      private final Set<Runnable> tasksCancelledAtShutdown = Collections.synchronizedSet(new HashSet<>());
		  
		      public List<Runnable> getCancelledTasks() {
		          if (!executorService.isTerminated()) {
		              throw new IllegalStateException("had not shutdown ");
		          }
		          return new ArrayList<>(tasksCancelledAtShutdown);
		      }
		  
		  
		      @Override
		      public void shutdown() {
		  
		      }
		  
		      @Override
		      public List<Runnable> shutdownNow() {
		          return null;
		      }
		  
		      @Override
		      public boolean isShutdown() {
		          return false;
		      }
		  
		      @Override
		      public boolean isTerminated() {
		          return false;
		      }
		  
		      @Override
		      public boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException {
		          return false;
		      }
		  
		      @Override
		      public void execute(Runnable command) {
		          executorService.execute(new Runnable() {
		              @Override
		              public void run() {
		                  try {
		                      command.run();
		                  } finally {
		                      if (isShutdown() && Thread.currentThread().isInterrupted()) {
		                          tasksCancelledAtShutdown.add(command);
		                      }
		                  }
		              }
		          });
		      }
		  }

### 3、处理非正常的线程终止

- 导致线程提前死亡的主要原因时RuntimeException。由于这些异常表示出现了某种编程错误或者其他不可修复的错误，因此他们呢通常不会被捕获。他们不会在调用堆栈中逐层传递，而是默认地在控制台中输出栈追踪信息，并终止线程
- 在任务处理线程的生命周期中，将通过某种抽象机制来调用许多未知的代码，应该对这些线程中执行的代码能否表现出正确的行为保持怀疑。

	- 典型的线程池工作者线程结构

	  public void run() {
	      Throwable throwable = null;
	      try {
	          while (!isInterrupted()) {
	              runTask(getTaskFromWorkQueue());
	          }
	      } catch (Throwable e) {
	          throwable = e;
	      } finally {
	          threadExited(this, throwable);
	      }
	  }

		- 如果抛出一个未检查异常，那么他将使线程终结，但会首先通知框架该线程已经终结。然后线程可能会用新的线程来代替这个工作线程，也可能不会。

- 未捕获异常的处理

	- Thread API中提供了UncaughtExceptionHandler，它能检测出某个线程由于未捕获的异常而终结的情况。这两种方法互补，就能有效防止线程泄露问题

	  class UEHLogger implements Thread.UncaughtExceptionHandler {
	      @Override
	      public void uncaughtException(Thread t, Throwable e) {
	          Logger logger = Logger.getAnonymousLogger();
	          logger.log(Level.SEVERE, "THread terminated with exception :"+ t.getName(), e);
	      }
	  }

		- 要为线程池中的所有线程设置一个UncaughtExceptionHandler，需要为ThreadPoolExecutor的构造函数提供一个ThreadFactory。与所有线程操控一样，只有线程的所有者能够改变线程的UncaughtExceptionHandler
		- 只有通过executor提交的任务，才能将他抛出的异常交给未捕获异常处理器，而通过submit提交的任务，无论是抛出的未检查异常还是已检查异常，都将被认为时任务返回状态的一部分。这个异常将被Future.get封装在ExecutionException中重新抛出

### 4、JVM关闭

- 正长关闭与非正常关闭

	- 当最后一个”正常(非守护)“线程结束时，或者当调用System.exit时，或者通过其他特定于平台的方法关闭时。
	- 调用Runtime.halt或者在操作系统中”杀死“JVM进程来强行关闭JVM

- 关闭钩子

	- 正常关闭中，JVM首先调用所有已注册的关闭钩子。关闭钩子是指通过Runtime.addShutdownHook注册的单尚未开始的线程。

		- JVM并不能保证关闭钩子的调用顺序
		- 执行顺序

			- 在关闭应用程序线程时，如果有线程仍在运行，那么这些线程接下来将于关闭进程并发执行。
			- 当所有的关闭钩子都执行完毕。如果runFinalizersOnExit为true，那么JVM将运行终结器，然后再停止。
			- JVM不会停止或中断任何再关闭时仍然运行的应用程序线程。当JVM最终结束时，这些线程将被强行结束。如果关闭钩子或终结器没有执行完成，那么正长关闭进程”挂起“并且JVM必须被强行关闭。当被强行关闭时，只是关闭JVM，而不会运行关闭钩子

	- 关闭钩子应该是线程安全的：他们再访问共享数据时必须使用同步机制。而且关闭钩子不应该对应用程序的状态或JVM的关闭原因租出任何假设。因此在编写关闭钩子时的代码时需要考虑周全。最后关闭钩子必须尽快退出，应为他们会雅虎吃JVM的结束时间
	- 关闭钩子可以用于实现服务或应用程序的清理工作，例如删除临时文件，或者清除无法由操作系统自动清除的资源。
	- 关闭钩子不应该依赖哪些可能被应用程序或其他关闭钩子关闭的服务。

	  void start() {
	      Runtime.getRuntime().addShutdownHook(new Thread() {
	          @Override
	          public void run() {
	              try {
	                  LoggerService.this.stop();
	  
	              } catch (InterruptedExceptione exceptione) {
	              }
	          }
	      });
	  }

		- 对所有服务使用同一个关闭钩子，并且在该关闭钩子中执行一序列的关闭操作，这确保了关闭操作再单个线程中串行执行，从而避免了再关闭操作之间出现静态条件或死锁问题

- 守护线程

	- 当需要创建一个线程来执行一些辅助工作，但又不希望这个线程阻碍JVM的关闭，这种情况下就需要使用守护线程。

		- 当创建一个新线程时，新线程将继承创建它的线程的守护状态。因此默认请开给你下，主线程创建的所有线程都是普通线程。

	- 普通线程与守护线程之间的差异载运当线程退出时发生的操作。当线程退出时，JVM会检查其他正在运行的线程，如果这些线程都是守护线程，那么JVM会正退出操作。当JVM停止时，所有仍存在的守护线程都将被抛弃。既不会执行finally代码块，也不会执行回卷栈。而JVM只是直接退出。

		- 尽可能少使用守护线程。很受有操作能够在不进行清理的情况下被安全地抛弃。

- 终结器

	- 当不在需要内存资源时，可以通过垃圾回收器来回收他们，但对于一些其他资源，例如文件句柄或套接字句柄，当不再需要他们时，必须显示地交还给操作系统。为了实现这个功能，垃圾回收器对那些定义了finalize方法的对象会进行特殊处理：再回收器释放他们后，调用它们的finalize方法，从而保证一些持久化的资源被释放。
	- 由于终结器可以在某个有JVM管理的线程种运行，因此终结器访问的任何状态都可能被多个线程访问这样就必须对其访问操作进行同步。
	- 终结器并不能保证他们呢将在何时运行甚至是否会运行，并且复杂的终结器通常会在对象上产生巨大的性能开销。

		- 大多数情况下，通过使用finally代码块和显示的close方法，能够比使用终结器更好的管理资源

			- 例外情况：当需要管理对象，并且该对象持有的资源是通过本地方法获得的。尽量避免编写或使用包含终结器的类。

## 线程池的使用

### 1、在任务与执行策略之间的隐形耦合

- 分类

	- 依赖性任务

		- 如果给线程池的任务需要依赖其他的任务，那么就隐含地给执行策略带来了约束

	- 使用线程封闭机制的任务

		- 单线程的Executor能够确保任务不会并发地执行，使得可能放宽代码对线程安全的要求。如果将Executor从单线程该队线程池环境，那么将失去线程安全性（隐式耦合--任务要求其执行所在的executor是单线程的）

	- 对响应时间敏感的任务

		- 将多个运行时间较长的任务提交到一个只包含少量线程的线程池中，将降低Executor管理的服务的响应性

	- 使用ThreadLocal的任务

		- 再线程池的线程中步应该使用ThreadLocal在任务之间传递值

- 只有当任务都是同类型的并且相互独立时，线程池的性能才能达到最佳
- 线程饥饿死锁

	- 如果所有正在执行任务的线程都由于等待其他仍处于工作队列中的任务而阻塞

		- 只要线程池中的任务需要无期限地等待一些必须由池中其他任务才能提供的资源或条件，除非线程池足够大，否则将发生线程饥饿死锁

- 运行时间较长的任务

	- 如果任务阻塞时间过长，那么即使不出现死锁，线程池的响应性也会变得糟糕。
	- 解决方法

		- 限定任务等待资源的时间，而不要无限制地等待

			- Thread.join、BlockingQueue.put、CountFownLatch.await、Selector.select

### 2、设置线程池的大小

- 线程池理想大小取决于被提交任务类型以及所部署系统的特性

	- 线程池池过大，大量的线程将在相对很少的CPU和内存资源上发生竞争，布景会导致更高的内存使用量，而且还可能耗尽资源
	- 线程池过小，将导致许多空闲的处理器无法执行工作，从而降低吞吐量
	- 需要分析的因素

		- CPU数量、内存大小、计算密集型/IO密集型、是否需要JDBC连接这样稀缺资源、如果执行不同类别的任务，他们之间的区别如果很大，那么应该考虑使用多个线程池，从而使每个线程池可以根据各自的工作负载来调整

- 计算密集型任务

	- 在拥有N个CPU的系统上，当线程池的大小为N+1时，通常能实现最优的利用率

- I/O操作或其他阻塞操作的任务，由于线程并不会一直操作，因此线程池的规模应该更大

	- 线程数量 = CPU数量*CPU负载*(1 + 任务等待时间/计算时间))

		- 任务等待时间/计算时间 不需要很精确，可以通过分析或监控工具获得
		- 在某个基准负载下，分别设置不同大小的线程池来运行应用程序，观察CPU利用率的水平

	- CPU周期、内存、文件句柄、套接字句柄和数据库连接都会影响线程池大小

		- 计算每个任务对该资源的需求量，然后用该资源的可用总量除以每个任务的需求量，结果就是线程池大小的上限

### 3、配置ThreadPoolExecutor

- ThreadPoolExecutor为Exector提供了基本的实现，这些Executor是由Executors中的newCachedThreadPool、newFixedThreadPool和newScheduleThreadPool等工厂方法返回的。
- public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue<Runnable> workQueue)
- 线程的创建与销毁

	- 线程池的基本大小、最大大小以及存活时间等因素共同分则线程的创建与销毁

		- 基本大小：线程池的目标大小，即在没有任务执行时线程池的大小，并且只有在工作队列满了的情况下才会创建超出这个数量的线程
		- 线程池的最终大小表示可同时活动的线程数量的上限

			- 可将线程池的基本大小设置为零，从而最终销毁工作者线程以免阻碍JVM的退出。奇怪行为：如果线程池中的线程数量等于线程池的基本大小，那么仅当工作队列已满的情况下才会创建新的线程

		- 如果某个线程的空闲时间操过了存货时间，那么将被标记为可回收的，并且当线程池的当前大小超过了基本大小时，这个线程将被终止

	- 通过调节线程池的基本大小和存活时间，可以帮助线程池回收空闲线程占有的资源，从而使得这些资源可以用于执行其他工作

		- newFixedThreadPool

			- 将线程池的基本大小和最大大小设置为参数中共指定的值，而且创建的线程池不会超时

		- newCachedThreadPool

			- 将线程池的最大大小设置为Integer.Max_Value，将基本大小设置为0，超时设置为1分钟。线程池可以无限扩展，需求降低时会自动收缩

- 管理队列任务

	- 在有限的线程池种会限制可并发执行的任务数量

		- 如果客户提交给服务器请求的速率操过了服务器的处理速率，可能会耗尽资源

	- ThreadExecutorPool允许提供一个BlockingQueue来保存等待执行的任务。基本的任务排队方式：无界队列，有界队列，同步移交（Synchronous Handoff）

		- 无界队列

			- newFixedThreadPool和newSingleThreadExecutor默认情况下使用无界的LinkedBlockingQueue

				- 当提交任务速度超过线程池处理速度。队列将无限制地增加

		- 有界队列

			- 更稳妥的资源管理策略。ArrayBlockingQueue、有界的LinkedBlockingQueue、PriorityBlockingQueue

				- 有助于避免资源耗尽情况的发生。当队列满后，新任务怎么办？
				- 使用有界队列，队列的大小与线程池的小必须一起调节。如果线程池较小队列较大，那么有助于减少内存的使用量，降低CPU的使用率，减少上下文切换，但是会限制吞吐量

		- 对于非常大或者无界的线程池，可以使用SynchronousQueue避免任务排队。以及直接将任务从生产者移交给工作者线程。

			- SynchronousQueue不是真正的队列，是一种子啊线程之间进行移交的机制。
			- 将一元素放入SynchronousQueue种，必须有另一个线程正在等待接收这个元素。如果没有线程正在等待，并且线程池的当前大小小于最大值，ThreadPoolExecutor将创建一个新的线程，否则根据饱和策略，这个任务将被拒绝
			- 使用直接移交将更高效，应为任务会直接移交给执行它的线程，而不是被首先放在队列中，然后由工作者线程从队列中提取该任务。
			- 只有当线程池时无界的或者可以拒绝任务时，SynchronousQueue才有实际价值。newCachedThreadPool使用了SynchronousQueue

		- 对于Executor，newCachedThreadPool是一种很好的默认选择，他能提供比固定大小的线程池更好的性能。当需要限制当前任务的数量以满足资源管理需求时，那么可以选择固定大小的线程池。

			- 接受网络客户端请求的服务器应用程序中，如果不限制，那么很容易发生过载问题。
			- 只有当热为奴相互独立时，为线程池或工作队列设置节限才是合理的。如果任务之间存在依赖性，那么有界的线程池或队列就可能导致线程“饥饿”死锁。此时使用无界的线程池。newCachedThreadPool

- 饱和策略

	- 当有界队列被填满后或者提交任务到被关闭的Executor时，饱和策略开始发挥作用。
	- AbortPolicy、CallerRunsPolicy、DiscardPolicy、DiscardOldestPolicy

		- AbortPolicy

			- 终止策略是默认的饱和策略，抛出未检查的RejectedExecutionException调用者可以捕获该异常，更具需求编写处理代码

		- DiscardPolicy

			- 抛弃策略会悄悄抛弃该任务

		- DiscardOldestPolicy

			- 会抛弃下一个将被执行的任务，然后尝试重新提交新的任务。如果工作队列是一个优先队列，则抛弃优先级最高的任务。不要将该策略和优先级队列一起使用

		- CallerRunsPolicy

			- 调用者运行策略实现了一种机制。该机制不会抛弃任务也不会抛出异常，而是将某些任务回退到调用者，从而降低新任务的流量。
			- 不会再线程池的某个线程中执行新提交的任务，而是在一个调用了execute的线程中执行该任务。

		- 使用semaphore控制任务提交速率

		  /**
		   * 使用semaphore控制任务提交速率
		   * */
		  public class BoundedExecutor {
		      private final Executor executor;
		      private final Semaphore semaphore;
		  
		      public BoundedExecutor(Executor executor, int bound) {
		          this.executor = executor;
		          this.semaphore = new Semaphore(bound);
		      }
		  
		      public void submitTask(Runnable runnable) throws InterruptedException {
		          semaphore.acquire();
		          try {
		              executor.execute(new Runnable() {
		                  @Override
		                  public void run() {
		                      try {
		                          runnable.run();
		                      } finally {
		                          semaphore.release();
		                      }
		                  }
		              });
		          } catch (RejectedExecutionException e) {
		              semaphore.release();
		          }
		      }
		  }

- 线程工厂

	- 通过指定一个线程工厂方法，可以定制线程池的配置信息

	  public class MyThreadFactory implements ThreadFactory {
	      private final String poolName;
	  
	      public MyThreadFactory(String poolName) {
	          this.poolName = poolName;
	      }
	  
	      @Override
	      public Thread newThread(Runnable runnable) {
	          return new MyThread(runnable);
	      }
	  }
	  
	  class MyThread extends Thread {
	      public static final String DEFAULT_NAME = "MyThreadName";
	  
	      private static volatile boolean debugLifecycle = false;
	      private static final AtomicInteger created = new AtomicInteger();
	      private static final AtomicInteger alive = new AtomicInteger();
	      private static final Logger log = Logger.getAnonymousLogger();
	  
	      public static int getThreadCreated() {
	          return created.get();
	      }
	  
	      public static int getThreadAlive() {
	          return alive.get();
	      }
	  
	      public static boolean getDebug() {
	          return debugLifecycle;
	      }
	  
	      public static boolean setDebug(boolean debug) {
	          return debugLifecycle = debug;
	      }
	  
	      public MyThread(Runnable runnable) {
	          this(runnable, DEFAULT_NAME);
	      }
	  
	      public MyThread(Runnable runnable, String name) {
	          super(runnable, name + "_" + created.incrementAndGet());
	          setUncaughtExceptionHandler(new UncaughtExceptionHandler() {
	              @Override
	              public void uncaughtException(Thread t, Throwable e) {
	                  log.log(Level.SEVERE, "uncaught in thread " + t.getName());
	              }
	          });
	      }
	  
	      @Override
	      public void run() {
	          boolean debug = debugLifecycle;
	          if (debug) {
	              log.log(Level.FINE, "create thread " + getName());
	          }
	  
	          try {
	              alive.incrementAndGet();
	              super.run();
	          } finally {
	              alive.decrementAndGet();
	              if (debug) {
	                  log.log(Level.FINE, "Exiting " + getName());
	              }
	          }
	      }
	  }

- 在调用构造函数后再定制ThreadPoolExecutor

	- 在调用完ThreadPoolExecutor的构造函数后，仍然可以通过设置函数来修改传递给构造函数的参数。

	  ExecutorService executorService = Executors.newCachedThreadPool();
	  if (executorService instanceof ThreadPoolExecutor) {
	      ((ThreadPoolExecutor) executorService).setCorePoolSize(10);
	  }

	- Executors种包含了一个unconfigurableExecutorService工厂方法，发i方法ui一个现有的ExecutorService进行包装，使其只包鲁出ExecutorService的方法，因此不能对他进行配置。newSingleThreadExecutor按照该方式封装ExecutorService，而不是最初的ThreadPoolExecutor。

		- 可以在自己的Executor中使用这项技术以防止执行策略被修改。如果将ExecutorService跑率给不信任的代码又不希望对其进行修改，就可以通过unconfigurableExecutorService来包装它

### 4、扩展ThreadPoolExecutor

- 扩展接口

	- beforeExecute

		- 如果抛出RuntimeException，任务将不会被执行，afterExecute也不会执行

	- afterExecute

		- 无任务时从run中正常返回，还是抛出一个异常而返回，afterExecute都会被调用。任务在完成后带有Error，那么就不会调用afterexcute

	- terminated

		- 线程池关闭时调用terminated，也就是所有任务都已经完成并且所有工作者线程也已经关闭后。terminated可以用来释放Executor在其生命周期里分配的各种资源，此外还可以执行发送通知、记录日志或者收集finalize统计信息等

### 5、递归算法的并行性

- 将串行执行转换为并行执行

  public class ProcessInParallel {
      void processInParallel(Executor executor, List<Element> elements) {
          for (final Element element : elements) {
              executor.execute(new Runnable() {
                  @Override
                  public void run() {
                      process(element);
                  }
              });
          }
      }
  
      private void process(Element element) {
  
      }
  }

- 将串行递归转换为并行递归

  public <T> void sequentialRecursive(List<Node<T>> nodes, Collection<T> results) {
      for (Node<T> node : nodes) {
          results.add(node.compute());
          sequentialRecursive(node.getChildren(), results);
      }
  }
  
  public <T> void parallelRecursive(final Executor executor, List<Node<T>> nodes, final Collection<T> results) {
      for (Node<T> node : nodes) {
          executor.execute(new Runnable() {
              @Override
              public void run() {
                  results.add(node.compute());
              }
          });
          parallelRecursive(executor, node.getChildren(), results);
      }
  }

	- page 155

## WebService实例修改为使用有界队列和“调用者运行”饱和策略，当线程池职工的所有线程都被占用，并且工作队列被填满后，下一个任务会在调用execute时会在主线程种执行。由于执行任务需要一定时间，因此主线程在一段时间按内不能提交任何任务，从而使得工作者线程有时间来处理正在执行的任务，在这期间主线程不会掉员工accept，因此到达的请求将被保存在TCP层的队列中而不是再应用程序的队列中。如果持续过载，TCP层终将发现它的请求队列被填满，因此同样会开始抛弃请求。当服务器过载时，这种情况会逐渐向外蔓延---从主线程到工作队列到应用程序再到TCP。最终到达客户端，导致服务器再高负载下实现一种品换的性能降低

public class LifecycleWebService {
    private final ExecutorService executorService = null; //new AbstractExecutorService() {

    public void start() throws IOException {
        ServerSocket socket = new ServerSocket(8080);
        while (!executorService.isShutdown()) {
            try {
                Socket socket1 = socket.accept();
                executorService.execute(new Runnable() {
                    @Override
                    public void run() {
                        handleRequest(socket1);
                    }
                });

            } catch (RejectedExecutionException e) {
                if (!executorService.isShutdown()) {
                }
            }
        }
    }

    public void stop() {
        executorService.shutdown();
    }

    private void handleRequest(Socket socket) {

    }
}

*XMind - Trial Version*